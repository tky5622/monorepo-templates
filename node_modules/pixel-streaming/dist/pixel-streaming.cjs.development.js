'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var CustomProvider = _interopDefault(require('rsuite/CustomProvider'));
var client = require('unreal-pixel-streaming');
var parse = _interopDefault(require('url-parse'));
var moment = _interopDefault(require('moment'));
var Notification = _interopDefault(require('rsuite/Notification'));
var toaster = _interopDefault(require('rsuite/toaster'));
var reactJss = require('react-jss');
var reactHotkeysHook = require('react-hotkeys-hook');
var IconButton = _interopDefault(require('rsuite/IconButton'));
var GearIcon = _interopDefault(require('@rsuite/icons/Gear'));
var Drawer = _interopDefault(require('rsuite/Drawer'));
var Sidenav = _interopDefault(require('rsuite/Sidenav'));
var Nav = _interopDefault(require('rsuite/Nav'));
var ListIcon = _interopDefault(require('@rsuite/icons/List'));
var HistoryIcon = _interopDefault(require('@rsuite/icons/History'));
var SettingIcon = _interopDefault(require('@rsuite/icons/Setting'));
var PlayOutlineIcon = _interopDefault(require('@rsuite/icons/PlayOutline'));
var ProjectIcon = _interopDefault(require('@rsuite/icons/Project'));
var ReactJson = _interopDefault(require('react-json-view'));
var CopyIcon = _interopDefault(require('@rsuite/icons/Copy'));
var Button = _interopDefault(require('rsuite/Button'));
var Form = _interopDefault(require('rsuite/Form'));
var Toggle = _interopDefault(require('rsuite/Toggle'));
var ButtonToolbar = _interopDefault(require('rsuite/ButtonToolbar'));
var SelectPicker = _interopDefault(require('rsuite/SelectPicker'));
var Input = _interopDefault(require('rsuite/Input'));
var Message = _interopDefault(require('rsuite/Message'));
var Modal = _interopDefault(require('rsuite/Modal'));
var Progress = _interopDefault(require('rsuite/Progress'));
var reactFontawesome = require('@fortawesome/react-fontawesome');
var freeSolidSvgIcons = require('@fortawesome/free-solid-svg-icons');
var InputGroup = _interopDefault(require('rsuite/InputGroup'));
var ReactQRCode = _interopDefault(require('react-qr-code'));
var Popover = _interopDefault(require('rsuite/Popover'));
var Whisper = _interopDefault(require('rsuite/Whisper'));
var Slider = _interopDefault(require('rsuite/Slider'));
var Navbar = _interopDefault(require('rsuite/Navbar'));
var Dropdown = _interopDefault(require('rsuite/Dropdown'));
var Animation = _interopDefault(require('rsuite/Animation'));

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * Class for the base overlay structure
 */

var OverlayBase = /*#__PURE__*/function () {
  /**
   * Construct an overlay
   * @param rootDiv the root element this overlay will be inserted into
   * @param rootElement the root element that is the overlay
   */
  function OverlayBase(rootDiv, rootElement) {
    this.rootDiv = rootDiv;
    this.rootElement = rootElement;
    this.rootElement.classList.add("hiddenState");
    this.rootDiv.appendChild(this.rootElement);
  }
  /**
   * Show the overlay
   */


  var _proto = OverlayBase.prototype;

  _proto.show = function show() {
    this.rootElement.classList.remove("hiddenState");
  }
  /**
   * Hide the overlay
   */
  ;

  _proto.hide = function hide() {
    this.rootElement.classList.add("hiddenState");
  };

  return OverlayBase;
}();
/**
 * Class for the base action overlay structure
 */

var ActionOverlayBase = /*#__PURE__*/function (_client$ActionOverlay) {
  _inheritsLoose(ActionOverlayBase, _client$ActionOverlay);

  /**
   * Construct an action overlay
   * @param rootDiv the root element this overlay will be inserted into
   * @param rootElement the root element that is the overlay
   * @param textElement an element that contains text for the action overlay
   */
  function ActionOverlayBase(rootDiv, rootElement, textElement) {
    var _this;

    _this = _client$ActionOverlay.call(this) || this;
    _this.rootDiv = rootDiv;
    _this.rootElement = rootElement;
    _this.textElement = textElement;

    _this.rootElement.appendChild(_this.textElement);

    _this.rootElement.classList.add("hiddenState");

    _this.rootDiv.appendChild(_this.rootElement);

    return _this;
  }
  /**
   * Show the overlay
   */


  var _proto2 = ActionOverlayBase.prototype;

  _proto2.show = function show() {
    this.rootElement.classList.remove("hiddenState");
  }
  /**
   * Hide the overlay
   */
  ;

  _proto2.hide = function hide() {
    this.rootElement.classList.add("hiddenState");
  };

  return ActionOverlayBase;
}(client.ActionOverlay);
/**
 * Class for the afk overlay base
 */

var AfkOverlayBase = /*#__PURE__*/function (_client$AfkOverlay) {
  _inheritsLoose(AfkOverlayBase, _client$AfkOverlay);

  /**
   * Construct an Afk overlay
   * @param rootDiv the root element this overlay will be inserted into
   * @param rootElement the root element that is the overlay
   * @param textElement an element that contains text for the action overlay
   * @param countDownSpanElementId the id of the span that holds the countdown element
   */
  function AfkOverlayBase(rootDiv, rootElement, textElement, countDownSpanElementId) {
    var _this2;

    _this2 = _client$AfkOverlay.call(this) || this;
    _this2.rootDiv = rootDiv;
    _this2.rootElement = rootElement;
    _this2.countDownSpanElementId = countDownSpanElementId;
    _this2.textElement = textElement;

    _this2.rootElement.appendChild(_this2.textElement);

    _this2.rootElement.classList.add("hiddenState");

    _this2.rootDiv.appendChild(_this2.rootElement);

    return _this2;
  }
  /**
   * Show the overlay
   */


  var _proto3 = AfkOverlayBase.prototype;

  _proto3.show = function show() {
    this.rootElement.classList.remove("hiddenState");
  }
  /**
   * Hide the overlay
   */
  ;

  _proto3.hide = function hide() {
    this.rootElement.classList.add("hiddenState");
  }
  /**
   * Update the count down spans number for the overlay
   * @param countdown the count down number to be inserted into the span for updating
   */
  ;

  _proto3.update = function update(countdown) {
    document.getElementById(this.countDownSpanElementId).innerHTML = countdown.toString();
  };

  return AfkOverlayBase;
}(client.AfkOverlay);
/**
 * Class for the text overlay base
 */

var TextOverlayBase = /*#__PURE__*/function (_OverlayBase) {
  _inheritsLoose(TextOverlayBase, _OverlayBase);

  /**
   * Construct a text overlay
   * @param rootDiv the root element this overlay will be inserted into
   * @param rootElement the root element that is the overlay
   * @param textElement an element that contains text for the action overlay
   */
  function TextOverlayBase(rootDiv, rootElement, textElement) {
    var _this3;

    _this3 = _OverlayBase.call(this, rootDiv, rootElement) || this;
    _this3.textElement = textElement;

    _this3.rootElement.appendChild(_this3.textElement);

    return _this3;
  }
  /**
   * Update the text overlays inner text
   * @param text the update text to be inserted into the overlay
   */


  var _proto4 = TextOverlayBase.prototype;

  _proto4.update = function update(text) {
    if (text != null || text != undefined) {
      this.textElement.innerHTML = text;
    }
  };

  return TextOverlayBase;
}(OverlayBase);
var NativeDOMDelegate = /*#__PURE__*/function (_client$DelegateBase) {
  _inheritsLoose(NativeDOMDelegate, _client$DelegateBase);

  function NativeDOMDelegate(config) {
    var _this4;

    _this4 = _client$DelegateBase.call(this, config) || this; // HTML Elements that are used multiple times
    // Global

    _this4.statusLight = document.getElementById("qualityStatus"); // Pre Stream options

    _this4.forceTurnToggle = document.getElementById("force-turn-tgl"); // Viewing

    _this4.qualityControlOwnershipCheckBox = document.getElementById("quality-control-ownership-tgl");
    _this4.toggleMatchViewPortRes = document.getElementById("match-viewport-res-tgl");
    _this4.controlSchemeToggle = document.getElementById("control-scheme-tgl");
    _this4.controlSchemeToggleTitle = document.getElementById("control-scheme-title"); // Commands

    _this4.uiDescriptorText = document.getElementById("ui-descriptor-text"); // Settings

    _this4.encoderMinQpText = document.getElementById("encoder-min-qp-text");
    _this4.encoderMaxQpText = document.getElementById("encoder-max-qp-text");
    _this4.webRtcFpsText = document.getElementById("webrtc-fps-text");
    _this4.webRtcMinBitrateText = document.getElementById("webrtc-min-bitrate-text");
    _this4.webRtcMaxBitrateText = document.getElementById("webrtc-max-bitrate-text"); // Statistics

    _this4.sendStatsToServer = document.getElementById("send-stats-tgl"); // Containers Headers

    _this4.preStreamContainer = document.getElementById("preStreamOptionsHeader");
    _this4.viewSettingsHeader = document.getElementById("viewSettingsHeader");
    _this4.commandsHeader = document.getElementById("commandsHeader");
    _this4.streamingSettingsHeader = document.getElementById("streamingSettingsHeader");
    _this4.statsHeader = document.getElementById("statisticsHeader");
    _this4.latencyHeader = document.getElementById("latencyTestHeader"); // Containers

    _this4.viewSettingsContainer = document.getElementById("viewSettingsContainer");
    _this4.commandsContainer = document.getElementById("commandsContainer");
    _this4.streamingSettingsContainer = document.getElementById("streamingSettingsContainer");
    _this4.statsContainer = document.getElementById("statisticsContainer");
    _this4.latencyContainer = document.getElementById("latencyTestContainer");
    _this4.showStats = true;
    _this4.logging = false;
    _this4.videoEncoderAvgQP = -1; // build all of the overlays 

    _this4.buildConnectOverlay();

    _this4.buildPlayOverlay();

    _this4.buildAfkOverlay();

    _this4.buildInfoOverlay();

    _this4.buildErrorOverlay(); // configure all buttons 


    _this4.ConfigureButtons();

    return _this4;
  }
  /**
   * Builds the connect overlay
   */


  var _proto5 = NativeDOMDelegate.prototype;

  _proto5.buildConnectOverlay = function buildConnectOverlay() {
    var _this5 = this;

    // build the overlay base div 
    var connectOverlayHtml = document.createElement('div');
    connectOverlayHtml.id = "connectOverlay";
    connectOverlayHtml.className = "clickableState"; // set the event Listener

    var connectOverlayEvent = function connectOverlayEvent() {
      return _this5.onConnectAction();
    }; // add the new event listener 


    connectOverlayHtml.addEventListener('click', function onOverlayClick(event) {
      connectOverlayEvent(); //connectOverlayHtml.removeEventListener('click', onOverlayClick);
    }); // build the inner html 

    var connectOverlayHtmlInner = document.createElement('div');
    connectOverlayHtmlInner.id = 'connectButton';
    connectOverlayHtmlInner.innerHTML = 'Click to start'; // instantiate the overlay

    this.connectOverlay = new ActionOverlayBase(this.config.playerElement, connectOverlayHtml, connectOverlayHtmlInner);
  }
  /**
   * Builds the play overlay
   */
  ;

  _proto5.buildPlayOverlay = function buildPlayOverlay() {
    var _this6 = this;

    // build the overlay base div 
    var playOverlayHtml = document.createElement('div');
    playOverlayHtml.id = "playOverlay";
    playOverlayHtml.className = "clickableState"; // set the event Listener

    var playOverlayEvent = function playOverlayEvent() {
      return _this6.onPlayAction();
    }; // add the new event listener 


    playOverlayHtml.addEventListener('click', function onOverlayClick(event) {
      playOverlayEvent(); //playOverlayHtml.removeEventListener('click', onOverlayClick);
    }); // build the inner html 

    var playOverlayHtmlInner = document.createElement('img');
    playOverlayHtmlInner.id = 'playButton';
    playOverlayHtmlInner.src = Images.playButton;
    playOverlayHtmlInner.alt = 'Start Streaming'; // instantiate the overlay

    this.playOverlay = new ActionOverlayBase(this.config.playerElement, playOverlayHtml, playOverlayHtmlInner);
  }
  /**
   * Builds the Afk overlay
   */
  ;

  _proto5.buildAfkOverlay = function buildAfkOverlay() {
    var _this7 = this;

    // build the overlay base div 
    var afkOverlayHtml = document.createElement('div');
    afkOverlayHtml.id = "afkOverlay";
    afkOverlayHtml.className = "clickableState";

    var afkOverlayEvent = function afkOverlayEvent() {
      return _this7.onAfkAction();
    };

    afkOverlayHtml.addEventListener('click', function onOverlayClick(event) {
      afkOverlayEvent(); //playOverlayHtml.removeEventListener('click', onOverlayClick);
    }); // build the inner html

    var afkOverlayHtmlInner = document.createElement('div');
    afkOverlayHtmlInner.id = 'afkOverlayInner';
    afkOverlayHtmlInner.innerHTML = '<center>No activity detected<br>Disconnecting in <span id="afkCountDownNumber"></span> seconds<br>Click to continue<br></center>'; // instantiate the overlay

    this.afkOverlay = new AfkOverlayBase(this.config.playerElement, afkOverlayHtml, afkOverlayHtmlInner, "afkCountDownNumber");
  }
  /**
   * Builds the info overlay
   */
  ;

  _proto5.buildInfoOverlay = function buildInfoOverlay() {
    // build the overlay base div 
    var infoOverlayHtml = document.createElement('div');
    infoOverlayHtml.id = "infoOverlay";
    infoOverlayHtml.className = "textDisplayState"; // build the inner html

    var infoOverlayHtmlInner = document.createElement('div');
    infoOverlayHtmlInner.id = 'messageOverlayInner'; /// instantiate the overlay

    this.infoOverlay = new TextOverlayBase(this.config.playerElement, infoOverlayHtml, infoOverlayHtmlInner);
  }
  /**
   * Builds the error overlay
   */
  ;

  _proto5.buildErrorOverlay = function buildErrorOverlay() {
    // build the overlay base div 
    var errorOverlayHtml = document.createElement('div');
    errorOverlayHtml.id = "errorOverlay";
    errorOverlayHtml.className = "textDisplayState"; // build the inner html

    var errorOverlayHtmlInner = document.createElement('div');
    errorOverlayHtmlInner.id = 'errorOverlayInner';
    errorOverlayHtmlInner.classList.add(".text-danger"); // instantiate the overlay

    this.errorOverlay = new TextOverlayBase(this.config.playerElement, errorOverlayHtml, errorOverlayHtmlInner);
  }
  /**
  * Set up functionality to happen when an instance state change occurs and updates the info overlay with the response
  * @param instanceState - the message instance state
  */
  ;

  _proto5.onInstanceStateChange = function onInstanceStateChange(instanceState) {
    var instanceStateMessage = "";
    var isInstancePending = false;
    var isError = false; // get the response type

    switch (instanceState.state) {
      case client.InstanceState.UNALLOCATED:
        instanceStateMessage = "Instance Unallocated: " + instanceState.details;
        break;

      case client.InstanceState.FAILED:
        instanceStateMessage = "UE Instance Failed: " + instanceState.details;
        isError = true;
        break;

      case client.InstanceState.PENDING:
        isInstancePending = true;

        if (instanceState.details == undefined || instanceState.details == null) {
          instanceStateMessage = "Your application is pending";
        } else {
          instanceStateMessage = instanceState.details;
        }

        break;

      case client.InstanceState.READY:
        instanceStateMessage = "Instance is Ready: " + instanceState.details;
        break;

      default:
        instanceStateMessage = "Unhandled Instance State" + instanceState.state + " " + instanceState.details;
        break;
    }

    if (isError) {
      this.showErrorOverlay(instanceStateMessage);
    } else if (isInstancePending) {
      //check if there is already and instance pending if so return 
      var preExistingPendingMessage = document.getElementById('loading-spinner');

      if (preExistingPendingMessage) {
        return;
      } // build the spinner span


      var spinnerSpan = document.createElement('span');
      spinnerSpan.className = "visually-hidden";
      spinnerSpan.innerHTML = "Loading..."; // build the spinner div

      var spinnerDiv = document.createElement('div');
      spinnerDiv.id = "loading-spinner";
      spinnerDiv.className = "spinner-border ms-2";
      spinnerDiv.setAttribute("role", "status"); // append the spinner to the element

      spinnerDiv.appendChild(spinnerSpan); // insert the inner html into the base div

      this.showTextOverlay(instanceStateMessage + spinnerDiv.outerHTML);
    } else {
      this.showTextOverlay(instanceStateMessage);
    }
  }
  /**
   * Set up functionality to happen when receiving an auth response and updates an info overlay with the response
   * @param authResponse - the auth response message type
   */
  ;

  _proto5.onAuthenticationResponse = function onAuthenticationResponse(authResponse) {
    var instanceStateMessage = "";
    var isError = false; // get the response type

    switch (authResponse.outcome) {
      case client.MessageAuthResponseOutcomeType.AUTHENTICATED:
        instanceStateMessage = "Authentication has succeeded. Requesting Instance";
        break;

      case client.MessageAuthResponseOutcomeType.INVALID_TOKEN:
        instanceStateMessage = "Invalid Token: " + authResponse.error;
        isError = true;
        break;

      case client.MessageAuthResponseOutcomeType.REDIRECT:
        instanceStateMessage = "Redirecting to: " + authResponse.redirect;
        break;

      case client.MessageAuthResponseOutcomeType.ERROR:
        instanceStateMessage = "Error: " + authResponse.error;
        isError = true;
        break;

      default:
        instanceStateMessage = "Unhandled Auth Response: " + authResponse.outcome;
        break;
    } // if the response is an error show the error instead of the info 


    if (isError) {
      this.showErrorOverlay(instanceStateMessage);
    } else {
      this.showTextOverlay(instanceStateMessage);
    }
  }
  /**
   * Set up button click functions and button functionality
   */
  ;

  _proto5.ConfigureButtons = function ConfigureButtons() {
    var _this8 = this;

    // setup the Force TURN toggle
    this.setUpToggleWithUrlParams(this.forceTurnToggle, "ForceTURN");
    this.setUpControlSchemeTypeToggle(this.controlSchemeToggle); // set up the restart stream button

    document.getElementById("restart-stream-button").onclick = function () {
      _this8.iWebRtcController.restartStreamAutomaticity();
    };

    document.getElementById("btn-streaming-settings").onclick = function () {
      console.debug("--------  Sending Streaming settings  --------");
      var encode = {
        MinQP: Number(_this8.encoderMinQpText.value),
        MaxQP: Number(_this8.encoderMaxQpText.value)
      };
      var webRtcSettings = {
        FPS: Number(_this8.webRtcFpsText.value),
        MinBitrate: Number(_this8.webRtcMinBitrateText.value) * 1000,
        MaxBitrate: Number(_this8.webRtcMaxBitrateText.value) * 1000
      };

      _this8.iWebRtcController.sendEncoderSettings(encode);

      _this8.iWebRtcController.sendWebRtcSettings(webRtcSettings);

      console.debug("-------------------------------------------");
    }; // sending UI descriptors 


    document.getElementById("sendUiDescriptor").onclick = function () {
      _this8.iWebRtcController.sendUeUiDescriptor(_this8.uiDescriptorText.value);
    }; // show the current fps on screen 


    document.getElementById("show-fps-button").onclick = function () {
      _this8.iWebRtcController.sendShowFps();
    }; // make the player fill the window


    document.getElementById("enlarge-display-to-fill-window-tgl").onchange = function () {
      _this8.iWebRtcController.resizePlayerStyle();
    }; // make the player match the view port resolution 


    this.toggleMatchViewPortRes.onchange = function () {
      _this8.iWebRtcController.matchViewportResolution = _this8.toggleMatchViewPortRes.checked;
    }; // quality control ownership checkbox 


    this.qualityControlOwnershipCheckBox.onchange = function () {
      if (_this8.qualityControlOwnershipCheckBox.checked === false) {
        _this8.iWebRtcController.sendRequestQualityControlOwnership();
      }
    }; // show and hide the optional buttons overlay 


    document.getElementById("overlayButton").onclick = function () {
      document.getElementById("overlaySettings").classList.toggle("d-none");
    };
  }
  /**
   * Set up toggle element for controlling hovering mouse or locked mouse
   * @param toggleElement the toggle html element to be set up
   */
  ;

  _proto5.setUpControlSchemeTypeToggle = function setUpControlSchemeTypeToggle(toggleElement) {
    var _this9 = this;

    if (toggleElement) {
      // set the state for the toggle based on the config
      if (this.config.controlScheme === client.ControlSchemeType.LockedMouse) {
        this.controlSchemeToggleTitle.innerHTML = "Control Scheme: Locked Mouse";
        this.controlSchemeToggle.checked = false;
      } else {
        this.controlSchemeToggleTitle.innerHTML = "Control Scheme: Hovering Mouse";
        this.controlSchemeToggle.checked = true;
      } // set the onChange event 


      toggleElement.onchange = function () {
        if (toggleElement.checked === true) {
          _this9.controlSchemeToggleTitle.innerHTML = "Control Scheme: Hovering Mouse";
          _this9.config.controlScheme = client.ControlSchemeType.HoveringMouse;

          _this9.iWebRtcController.activateRegisterMouse();
        } else {
          _this9.controlSchemeToggleTitle.innerHTML = "Control Scheme: Locked Mouse";
          _this9.config.controlScheme = client.ControlSchemeType.LockedMouse;

          _this9.iWebRtcController.activateRegisterMouse();
        }
      };
    }
  }
  /**
   * Set up url toggle buttons
   * @param toggleElement the toggle element being activated
   * @param urlParameterKey the url key that is being made use of
   */
  ;

  _proto5.setUpToggleWithUrlParams = function setUpToggleWithUrlParams(toggleElement, urlParameterKey) {
    if (toggleElement) {
      //Check if the element has been set from the URL Params 
      toggleElement.checked = new URLSearchParams(window.location.search).has(urlParameterKey);

      toggleElement.onchange = function () {
        var urlParams = new URLSearchParams(window.location.search);

        if (toggleElement.checked === true) {
          urlParams.set(urlParameterKey, "true");
        } else {
          urlParams["delete"](urlParameterKey);
        }

        window.history.replaceState({}, '', urlParams.toString() !== "" ? location.pathname + "?" + urlParams : "" + location.pathname);
      };
    }
  }
  /**
   * Disable shared session links for all players
   * @returns false
   */
  ;

  _proto5.IsLinkSharingEnabled =
  /*#__PURE__*/
  function () {
    var _IsLinkSharingEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", false);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function IsLinkSharingEnabled() {
      return _IsLinkSharingEnabled.apply(this, arguments);
    }

    return IsLinkSharingEnabled;
  }()
  /**
   * Handle when the Video has been Initialised
   */
  ;

  _proto5.onVideoInitialised = function onVideoInitialised() {
    var _this10 = this;

    // starting a latency check
    document.getElementById("btn-start-latency-test").onclick = function () {
      _this10.iWebRtcController.sendLatencyTest();
    }; // Set up overlay header functionality


    this.viewSettingsHeader.onclick = function () {
      _this10.viewSettingsContainer.classList.contains("d-none") ? _this10.viewSettingsContainer.classList.remove("d-none") : _this10.viewSettingsContainer.classList.add("d-none");
    };

    this.commandsHeader.onclick = function () {
      _this10.commandsContainer.classList.contains("d-none") ? _this10.commandsContainer.classList.remove("d-none") : _this10.commandsContainer.classList.add("d-none");
    };

    this.streamingSettingsHeader.onclick = function () {
      _this10.streamingSettingsContainer.classList.contains("d-none") ? _this10.streamingSettingsContainer.classList.remove("d-none") : _this10.streamingSettingsContainer.classList.add("d-none");
    };

    this.statsHeader.onclick = function () {
      _this10.statsContainer.classList.contains("d-none") ? _this10.statsContainer.classList.remove("d-none") : _this10.statsContainer.classList.add("d-none");
    };

    this.latencyHeader.onclick = function () {
      _this10.latencyContainer.classList.contains("d-none") ? _this10.latencyContainer.classList.remove("d-none") : _this10.latencyContainer.classList.add("d-none");
    }; // Reveal all the container


    this.viewSettingsContainer.classList.remove("d-none");
    this.commandsContainer.classList.remove("d-none");
    this.streamingSettingsContainer.classList.remove("d-none");
    this.statsContainer.classList.remove("d-none");
    this.videoStartTime = Date.now();
  }
  /**
   * Extended from the base functionality; displays the text overlay and resets the buttons overlay upon disconnect
   * @param event
   */
  ;

  _proto5.onDisconnect = function onDisconnect(event) {
    // display the text overlay by calling its super method so it will use its default behavior first 
    _client$DelegateBase.prototype.onDisconnect.call(this, event); // update all of the tools upon disconnect 


    this.onVideoEncoderAvgQP(-1); // starting a latency check

    document.getElementById("btn-start-latency-test").onclick = function () {}; // Set up overlay header functionality


    this.viewSettingsHeader.onclick = function () {};

    this.commandsHeader.onclick = function () {};

    this.streamingSettingsHeader.onclick = function () {};

    this.statsHeader.onclick = function () {};

    this.latencyHeader.onclick = function () {}; // Hide all the containers


    this.viewSettingsContainer.classList.add("d-none");
    this.commandsContainer.classList.add("d-none");
    this.streamingSettingsContainer.classList.add("d-none");
    this.statsContainer.classList.add("d-none");
  }
  /**
   * `Takes the InitialSettings and wired to frontend
   * @param settings - Settings sent from the UE Instance`
   */
  ;

  _proto5.onInitialSettings = function onInitialSettings(settings) {
    if (settings.Encoder) {
      this.encoderMinQpText.value = settings.Encoder.MinQP.toString();
      this.encoderMaxQpText.value = settings.Encoder.MaxQP.toString();
    }

    if (settings.WebRTC) {
      this.webRtcMinBitrateText.value = settings.WebRTC.MinBitrate.toString();
      this.webRtcMaxBitrateText.value = settings.WebRTC.MaxBitrate.toString();
      this.webRtcFpsText.value = settings.WebRTC.FPS.toString();
    }
  }
  /**
  * Used to handle the Video Stats from the Peer Connection Client
  * @param stats - Stats generate from the Peer Connection Client
  */
  ;

  _proto5.onVideoStats = function onVideoStats(stats) {
    var runTime = new Date(Date.now() - this.videoStartTime).toISOString().substr(11, 8);
    var statsText = "";
    var inboundData = this.formatBytes(stats.inboundVideoStats.bytesReceived, 2);
    statsText += "<div>Duration: " + runTime + "</div>";
    statsText += "<div>Inbound Video Data Received: " + inboundData + "</div>";
    statsText += "<div>Packets Lost: " + stats.inboundVideoStats.packetsLost + "</div>";
    statsText += "<div>Bitrate (kbps): " + stats.inboundVideoStats.bitrate + "</div>";
    statsText += "<div>Framerate: " + stats.inboundVideoStats.framerate + "</div>";
    statsText += "<div>Frames dropped: " + stats.inboundVideoStats.framesDropped + "</div>";
    statsText += "<div>Net RTT (ms): " + stats.candidatePair.currentRoundTripTime + "</div>";
    statsText += "<div>Browser receive to composite (ms): " + stats.inboundVideoStats.receiveToCompositeMs + "</div>";
    statsText += "<div>Video Quantization Parameter: " + this.videoEncoderAvgQP + "</div>"; //document.getElementById("statsTitle").style.display = "";

    var statsDiv = document.getElementById("statisticsResult");
    statsDiv.innerHTML = statsText;

    if (this.logging) {
      client.Logger.verboseLog("--------- Stats ---------\n " + stats + "\n------------------------");
    }

    if (this.sendStatsToServer.checked === true) {
      this.iWebRtcController.sendStatsToSignallingServer(stats);
    }
  }
  /**
  * formats Bytes coming in for video stats
  * @param bytes number to convert
  * @param decimals number of decimal places
  */
  ;

  _proto5.formatBytes = function formatBytes(bytes, decimals) {
    if (bytes === 0) {
      return "0";
    }

    var factor = 1024;
    var dm = decimals < 0 ? 0 : decimals;
    var sizes = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
    var i = Math.floor(Math.log(bytes) / Math.log(factor));
    return parseFloat((bytes / Math.pow(factor, i)).toFixed(dm)) + ' ' + sizes[i];
  }
  /**
  * Handles the result of the UE Latency Test
  * @param latencyTimings - Latency Test Timings sent from the UE Instance
  */
  ;

  _proto5.onLatencyTestResult = function onLatencyTestResult(latencyTimings) {
    console.log(latencyTimings);
    var latencyStatsInnerHTML = '';
    latencyStatsInnerHTML += "<div>Net latency RTT (ms): " + latencyTimings.networkLatency + "</div>";
    latencyStatsInnerHTML += "<div>UE Encode (ms): " + latencyTimings.EncodeMs + "</div>";
    latencyStatsInnerHTML += "<div>UE Capture (ms): " + latencyTimings.CaptureToSendMs + "</div>";
    latencyStatsInnerHTML += "<div>Browser send latency (ms): " + latencyTimings.browserSendLatency + "</div>";
    latencyStatsInnerHTML += latencyTimings.frameDisplayDeltaTimeMs && latencyTimings.browserReceiptTimeMs ? "<div>Browser receive latency (ms): " + latencyTimings.frameDisplayDeltaTimeMs + "</div>" : "";
    latencyStatsInnerHTML += "<div>Total latency (excluding browser) (ms): " + latencyTimings.latencyExcludingDecode + "</div>";
    latencyStatsInnerHTML += latencyTimings.endToEndLatency ? "<div>Total latency (ms): " + latencyTimings.endToEndLatency + "</div>" : "";
    this.latencyContainer.classList.remove("d-none");
    document.getElementById("latencyStatsResults").innerHTML = latencyStatsInnerHTML;
  }
  /**
      *
      * converts the Video Encoder QP to a colour light
      * @param QP - The video encoder QP number needed to find the average
      */
  ;

  _proto5.onVideoEncoderAvgQP = function onVideoEncoderAvgQP(QP) {
    this.videoEncoderAvgQP = QP;
    this.statusLight.style.color = QualityColour.None;
    this.statusLight.title = "QP: " + QP;

    if (QP > QualityThresholds.Bad) {
      this.statusLight.style.color = QualityColour.Bad;
      this.statusLight.title += " - Bad";
      this.BlinkVideoQualityStatus(2);
    } else if (QP > QualityThresholds.Spotty) {
      this.statusLight.style.color = QualityColour.Spotty;
      this.statusLight.title += " - Spotty";
      this.BlinkVideoQualityStatus(1);
    } else if (QP < 0) {
      this.statusLight.style.color = QualityColour.None;
      this.statusLight.title += " - Error";
      console.error("Video Encoder QP can not be less then 0");
    } else {
      this.statusLight.title += " - Good";
      this.statusLight.style.color = QualityColour.Good;
    }
  }
  /**
   * Handles when the ownership flag is sent from the signaling server
   * @param hasQualityOwnership - flag if the user has quality ownership
   */
  ;

  _proto5.onQualityControlOwnership = function onQualityControlOwnership(hasQualityOwnership) {
    this.qualityControlOwnershipCheckBox.checked = hasQualityOwnership;
  }
  /**
   * used to set the speed of the status light
   *
   * @param speed - Set the speed of the blink if the status light higher the speed the faster the blink
   */
  ;

  _proto5.BlinkVideoQualityStatus = function BlinkVideoQualityStatus(speed) {
    var _this11 = this;

    var iteration = speed;
    var opacity = 1;
    var tickID = setInterval(function () {
      opacity -= 0.1;
      _this11.statusLight.style.opacity = String(Math.abs((opacity - 0.5) * 2));

      if (opacity <= 0.1) {
        if (--iteration == 0) {
          clearInterval(tickID);
        } else {
          opacity = 1;
        }
      }
    }, 100 / speed);
  } // ::START
  ;

  _proto5.afkConnect = function afkConnect() {
    this.iWebRtcController.connectToSignallingSever();
  };

  _proto5.sendEncoderSettings = function sendEncoderSettings(payload) {
    this.iWebRtcController.sendEncoderSettings(payload);
  };

  _proto5.sendWebRtcSettings = function sendWebRtcSettings(payload) {
    this.iWebRtcController.sendWebRtcSettings(payload);
  };

  return NativeDOMDelegate;
}(client.DelegateBase);
/**
 * Used for Setting the colour of the Status Light
 */

var QualityColour;

(function (QualityColour) {
  QualityColour["Good"] = "lime";
  QualityColour["Spotty"] = "orange";
  QualityColour["Bad"] = "red";
  QualityColour["None"] = "black";
})(QualityColour || (QualityColour = {}));
/**
 * Used to set the Quality Thresholds of the Video Encoder QP
 */


var QualityThresholds;

(function (QualityThresholds) {
  QualityThresholds[QualityThresholds["Spotty"] = 26] = "Spotty";
  QualityThresholds[QualityThresholds["Bad"] = 35] = "Bad";
})(QualityThresholds || (QualityThresholds = {}));
/**
 * The static image for the play button
 */

var Images = function Images() {};
Images.playButton = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAAD5CAYAAAD2mNNkAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMjHxIGmVAAASgklEQVR4Xu2dC7BdVX2HqUCCIRASCPjAFIQREBRBBSRYbFOt8lIrFUWRFqXWsT5wbItUqFWs0KqIMPKoYEWpRS06KDjS1BeVFkVQbCw+wCfiAwGhCKWP9PuZtU24uTe59zz22Y/vm/nGkXtz7jlrr9+sdfZea/03Wb169QtxGW62iYi0D8L7NbwYj8EdcdPyIxFpA4T2P/F/8Ua8CI/GhPnXyq+ISJMhrAlxxX9hRuYL8Sh8SPk1EWkqBHXdEFfcg6vw3fhs3Kb8uog0DQI6XYgr8rOvYsJ8OM4v/0xEmkIJ6ob4P8zIfANegCvQMIs0BQK5sRBXJMy/wIzM5+ByXFBeRkQmBUGcbYjX5S5MmM/AA3CL8nIiUjcEcJAQV9yBX8a/wSeiz5hF6obgDRPikGfMCfOX8DTcu7y0iNQBoRs2xBX/g3diwvwm3Kn8CREZJ4RtVCGuqMKcu9kn4xJ09ZfIuCBgow5xyJ3sTLNzAywrwF6J26NhFhk1BGscIV6XhPluvA6Pxx3KnxaRUUCoxh3iioQ5z5n/BY/FJeUtiMgwEKa6QlyRMN+Hn8Hn4ZblrYjIIBCiukMc8p25Ws6ZMD+zvB0RmSsEaBIhnkrew5V4EHrCiMhcKAFqCv+Nl+J+uBC9my2yMQhKk0Jcke/M78Gsy06YH1TerohMhYA0McQVP8Nz8UDcCl2bLTIVgtHkEFd8D8/E/XFrdGQWqSAQbQhxyKOpm/B03Ac9MkgkEIa2hLgiN78S5lPx0bgIvQEm/YUAtC3EFQnzzfgnuDc6zZZ+Qsdva4jX5Sv4atwXHZmlX9DhuxDikC2Qn8dXYUbmReUjinQbOntXQlyRTRafwldgwrxV+agi3YRO3rUQV/wcV+LL8DHoyZzSTejcXQ1xRc7/uhyzl3kv3Lx8dJFuQKfueohDnjFnZP4o/j7m0ZQH4Es3oDP3IcQV2f6YMF+COZjgUeiZ2dJu6MR9CvG63ILvx4zMCfO80iQi7YLO29cQV3wb34spsr4rumBE2gWdtu8hDln99S1MXeYX4M6leUSaDx3WEK8lRdYT5lR/zPlfnswpzYeOaojXJ4cSfB3Pw+fgtug0W5oJndMQT0/uZGeaXZVyfTZuV5pNpDnQMQ3xxsk0O9Ufz8ZDcdvSfCKThw5piGdP2ioF496JT0c3WcjkKR1T5kYWjCTM78DfQheMyOSgAxriwch35lR/vAbPwOXozS+pHzqeIR6Oal12wvx2fBy6yULqgw5niEdDwpyR+VpMkfXsmHIpp4wfOpohHj234RfwFNwDnWbL+KCDGeLxkJH5p3g1vg53K00uMlroXIZ4vGTBSMJ8FeZkzmWl6UVGA53KENfD/ZiyNCmynvO/FpdLIDIcdCZDXC8ZmfOd+d/wJejZXzIcdCJDXD95xpwjdnP+V74zH4Wu/pLBoPMY4smSMN+FKbJ+BBpmmRt0GkPcDBLmu/FjeAi6lFNmB53FEDeHTLPzaCoj80dwBfqMWTYMncQQN5esAPsw7lcul8j60EEMcfPJDbD3YU7l3KxcOpE10CkMcTvIVDvfmc/E3XELtPqjGOKWkhVgp+GemDD7vbnP0AEMcXtJkfU34GNxAToy9xEuvCFuP6vwJMyOqYXl0kpf4KIb4m5QncyZTRapZGGY+wIX2xB3i3vxOswmi13QaXbX4QIb4m6SY3a/iMdh7mYb5q7ChTXE3aXaaLESq7rMW5ZLL12Bi2qI+8E9eDkmzLuhYe4KXExD3B8yMt+Ol+KL0CLrXYCLaIj7R8J8K16CR6PLOdsMF88Q95fsmPoRXozPxdzNdvVX2+CiGWLJza+EOXWZj8Sd0APw2wIXyxBLqPYy34LnY8K8DA1z0+EiGWKZSgJ9I74LU2R9R3Sa3VS4OIZYZqJaynkWpsj6w0u3kSbBhTHEsjHuwxswpVwPw6Wl+0gT4IIYYpkNmWKnr1yPqf54KG5VupFMknJhRGZLwpzVX6n++DZ8GrpjapJwAQyxDELCnB1TqWTx1/gUdGSeBDS8IZZBSZBjzv76PP4VHoSGuU5ocEMsoyBhTsG4VH98Ix6A80s3k3FCQxtiGSVZMPIT/CwmzPuhz5jHCQ1siGUcZClnwvxpPAX3LF1ORg2Na4hlXGSKnQUjCfNn8PX4CNy0dD8ZBTSoIZZxkzBXI/Pn8ATMumzDPApoSEMsdZEw5zvzDzHT7JdjwuzZX8NAAxpimQSZZifMn8Tj8aGlS8pcofEMsUyKjMw5lTOnjHwcc2TQktI1ZbbQaIZYJk3CnE0WGZmvwOeh+5hnC41liKUpVCNzwvwJPBy9+bUxaCRDLE0jYb4fU/0x0+yD8cGly8pUaBxDLE0kQa7CfCfmML8D0SN2p0KjGGJpOglztWgkh/k9CT1it4LGMMTSFhLmLBrJ3exzcJ/SjfsNDWGIpY0k0D/AM/GRpTv3ExrAEEubqVaAnY5LsX93s/nQhli6QLUF8nWYI3bnYT+Wc/JBDbF0heqO9jfwlfhInI/dDjMf0BBLF0mYr8NsskiNqS2wm2Hmgxli6TJ5zpwjg/4Qd8buLRrhQxli6QM5ZjdHBh2H+c7cnUUjfBhDLH0hU+y7cCU+H7OXeV6JQnvhQxhi6RsJc0bmy/BZ+MsbYCUS7YM3b4ilryTM2QL5QUzBuHxnbt80mzdtiEVWr74NL8KUck2R9faMzLxZQyyyhozMWcp5If4uJszNP5yAN2mIRR5IVn/djOfhEdjsw/x4c4ZYZHryjPkmPBsPwYeV2DQL3pghFpmZTLFzZFDCnLrMz8DtsTkbLXgzhlhk4yTM2cu8CrNjKiNzwjz5OlO8CUMsMjcS5qzLfgumyPr2JU6TgTdgiEUGoyqynrrMv42TOTObP2yIRQYn0+ws5bwaU8r1N3HrEq964A8aYpHhSZjvwBSMS5gPwnrWZfOHDLHI6Mgz5hyxm4Jxf4kH4HjDzB8wxCKjJ2HONPuf8c9xHxzPXmZe2BCLjIdMsWMqWfwTnoiPwdGOzLygIRYZPwlzVWPqtbgXjmbBCC9kiEXqI8+Ys8nicnwN7laiODi8iCEWqZeMylmXnTCnYFxO5tyxRHLu8I8NschkSJizLvv7mJH5pbgY57Zjin9giEUmSzUyfw9TZP1Y3LZEdOPwy4ZYpBkkzKn++B38KB6F25Wozgy/ZIhFmkXCnLO/vosfwpwysqhEdn34oSEWaSYJ8y8w0+wP4GG4/oIR/qMhFmk2VZgzzU6Ys2Nq7T5m/o8hFmkHCXO2PybMF+O++CBDLNIuEuSsy8535lvxZEMs0j6qWszZJbXUEIu0i1vwrZhqFZv5nVikPWTqfA5mF9QDD+fjPxhikeaR777xdrwAn1Aiuz780BCLNIvsdMqBAqkNtRw3XBeKXzDEIpMno27Cezdeik/GBSWmG4ZfNMQikyPhzXrpVGXM6R8rcG7lVfkHhlikfhLe7FzKo6KV+Hu45m7zXOEfGmKReske4oT3k3gMblniOBi8gCEWqYeMvD/GK/F43KHEcDh4IUMsMl5yw+pHmLOoX4aDH8UzHbygIRYZD/nem5H3KjwBd8LRV1HkRQ2xyGjJ3eacNZ1iayfhr+P46hnz4oZYZDRk2pzwph7TX+CuOP76xfwRQywyHNlVVIX3VHx8iVc98AcNscjgZJFGypq+GffHwZ71DgN/1BCLzJ2f47/iWzBlTId71jsM/HFDLDI7crf5HrwG34YHY70FxaeDN2GIRTZMwpvjcK7Fd+BTcfLhreDNGGKRmcnIez2+Ew/FhTi3MivjhjdkiEXWJ0fEfhXPwmfi4hKZ5sGbM8Qia8n65lX4LkzlhYeVqDQX3qQhFlnzrPc/8FzMtsBl2Kxp80zwRg2x9J0cxn4epoBZlkjW/6x3GHjDhlj6SJZI5gTJ9+DzMeHdvMSiXfDGDbH0iWpbYMqgJLy7YLtG3qnwAQyx9IVsC7wEX4C74/h2FtUJH8QQS9fJUTg5QfI43APnle7fDfhAhli6So5//Ri+GBPeya1vHid8MEMsXSMH0X0CX4J74cLS3bsJH9AQS1fITavs6f1VeLEdz3qHgQ9piKXtZHNC1jfnELpfTpux++Gt4MMaYmkrmTZ/GV+LCW+3p80zwQc3xNI2skTyBswhdHtic7YFTgIawBBLm7gRT8HH4dbYn2nzTNAIhljaQCrkvwkT3tywGv8pkm2BxjDE0lRyokbOsjoDUyE/N6wM71RoFEMsTSPhvRPfjY/GBei0eSZoHEMsTeJ2/ADug+3cVVQ3NJQhliaQkfcf8SnoqDsXaDBDLJMij4ruxcvwaejIOwg0nCGWusnyyIT3CjwM+7lIY1TQgIZY6iA3qzLyZmdRSn0eic09QbJN0JCGWMZJwpuR9w78Er4Qu7klcFLQoIZYxkXq9OZuc2oWZXNCv5dHjgsa1hDLqKnCm2qB2Zzw0NLdZBzQwIZYRkWmzT/DhPdE3KV0MxknNLQhlmHJ996ENwXHsjkhq6xcHlkXNLYhlkFJeHPDKhvyszkh4W338a9thEY3xDJX8qgoGxMS3tTpfSzOL11K6obGN8QyWxLeLI/MtDmlPvdHp82ThotgiGU2ZOStwrsCXSLZFLgYhlg2xF2Yc6zOxqejCzWaBhfFEMt0pMj2VzB1eg/BJaXLSNPg4hhiqcjd5izUSIX8lPp8Fi4tXUWaChfJEEtIhfwU2b4QU2R7O3RfbxvgQhnifpOD17+JCW9KfS5F7zi3CS6YIe4nOXj9W/h3eAw+vHQJaRtcPEPcL/Ks92a8CI/FXdFpc5vhAhri/vB9/Hv8A3wUukSyC3AhDXH3+Sn+Ax6PqZDvEskuwQU1xN2kOgonJ0im1Gc2J2xRLrt0CS6sIe4W1c6ij2NG3lROmFcut3QRLrAh7g4J75X4R7g3Gt4+wIU2xO0n0+ZP4aswBcdc39wnuOCGuL3kWe/n8DW4Ly4ql1X6BBfeELeTL+AJ+ATcBn3W21e4+Ia4PeSO89fwT/GJuAhdItl36ASGuPlkZ9G38fWYo3Ay8hpeWQOdwRA3lxwBexO+GVPq07Insj50DEPcTLK++e2Yc6wWo995ZXroHIa4WdyKOQpnOWbavGm5VCLTQycxxM0gp0iej0/G3LAyvDI76CyGeHJUx+G8Hw9Ewytzh05jiCdDDqK7HA/Aheh3XhkMOo8hrpe096fxd9D9vDI8pVPJ+LkXP4vPQafMMjroUIZ4fOQ7b9Y3X4U5x8oi2zJ66FiGePRkeWROkfwiHoee3Szjgw5miEdDRt14D+bw9ZfjDqWZRcYHHc0QD091FE6OgP0z9OB1qQ86myEenKxtTngz8r4BHXmlfuh4hnjuJLwp9Zlqgafh7qU5ReqHDmiIZ0+mzVkeeQO+FR9fmlFkctARDfHsSJ3ef8dqZ5GH0EkzoDMa4pnJ3ea0T07TOAezvnlBaTqRZlA6qTyQhDdrm1fhBXgwGl5pJnROQ7yW6jlvwvtefAZuXppKpJmUTitrp80p9Zn1zQ8uTSTSbOisfQ9xps2pkJ/wPhe3K00j0g7otH0N8f34dXwfHo0W2ZZ2QuftY4izPDKnabwIH4Ee/yrthQ7clxBnldUP8BJ8MSa87uuV9kNH7nqIc4ZVwvshfCkuQ8Mr3YEO3dUQZ4nkD/HDmFKfe5SPLNIt6NxdDHHC+xF8BabsiSOvdBc6eJdCfBtehglvimz7rFe6Dx29CyHOQo0r8NWYOr0W2Zb+QIdva4izRDLPeldi6vSm1OfC8rFE+gMdv40hznu+GlMhfz/cEj0OR/oJnb9NIc57vQZPxCehI69ICUbTydnN1+LJmPAuKW9fRAhEk0OcZ73XYw6hOwg9v1lkKgSjqSHO5oRT8TdwKbq+WWQ6CEeTQpw7zlmocTqmTm/Ob7bomMiGICRNCHGmzT/BszClPjPyuspKZDYQlkmH+Mf4t7gct0enzSJzgdBMKsQJ70X4VHTkFRkUwlN3iFM54YN4KG6LHkQnMgyEqK4Q51nvpZjwZuQ1vCKjgDDVEeIr8XBMeL3bLDJKCNW4QpyR9zo8ArdBb1iJjAPCNeoQJ7ypFngszkc3JoiME0I2qhDnWW8Kjv0xujFBpC4I3DAhzgqrHESXUp/Z0/uQ8rIiUhcEb5AQJ7z34TfwJNy5vJyI1A0BnG2IE9yYsiffwTfizuh3XpFJQghnE+J83014v4upkL8r+qhIpAkQxg2FOOHNzzNtPhf3REdekSZRQjqVTJtzguSNeD4eWH5dRJoGAZ0a4rvxm3ghrkCnzSJNhpBWIc7/plpgwpudRZ7dLNIGCOvtJbwX42G4uPxIRNoAoU2d3iNxUflPItIaNtnk/wEGBoMdpECGHAAAAABJRU5ErkJggg==";

var Logger = client.Logger,
    EventsClass = client.EventsClass;
var ClientClass = /*#__PURE__*/function () {
  function ClientClass(streamingUrl, psConfig) {
    this.streamingUrl = streamingUrl;
    this.psConfig = psConfig;
  }

  var _proto = ClientClass.prototype;

  _proto.init = function init() {
    var _this = this;

    // if (window.RTCPlayer) return window.RTCPlayer
    // build the websocket endpoint based on the protocol used to load the frontend
    var url_parsed = parse(this.streamingUrl, true); // define our signallingServerProtocol to be used based on whether
    // or not we're accessing our frontend via a tls

    var signallingServerProtocol = 'ws:';

    if (url_parsed.protocol === 'https:') {
      signallingServerProtocol = 'wss:';
    }

    var signallingServerAddress = signallingServerProtocol + '//' + url_parsed.hostname; // Create a config object instance 

    var CreateConfig = function CreateConfig(signalingAddress, playerElement) {
      var config = new client.Config(signalingAddress, playerElement); // Config performer

      var getCfg = function getCfg(v, def) {
        var cfg = _this.psConfig;

        if (typeof v === 'undefined' || !cfg.hasOwnProperty(v)) {
          return def;
        }

        return cfg[v];
      };

      client.Config._enableVerboseLogging = getCfg('enableVerboseLogging', false);
      config.enableSpsAutoplay = getCfg('enableSpsAutoplay', true);
      config.startVideoMuted = getCfg('startVideoMuted', false);
      config.controlScheme = getCfg('controlScheme', client.ControlSchemeType.HoveringMouse);
      config.suppressBrowserKeys = getCfg('suppressBrowserKeys', true);
      config.fakeMouseWithTouches = getCfg('fakeMouseWithTouches', true);
      return config;
    }; // Create a config object


    var config = CreateConfig(signallingServerAddress, "player"); // Create a Native DOM delegate instance that implements the Delegate interface class

    var delegate = new NativeDOMDelegate(config); // Create and return a new webRtcPlayerController instance 

    var RTCPlayer = create(config, delegate); // create takes in a delage interface type which our NativeDomDelegate class implements

    function create(config, delegate) {
      return new client.webRtcPlayerController(config, delegate);
    }

    document.ontouchmove = function (event) {
      event.preventDefault();
    }; // Apply client to window


    window.RTCPlayer = RTCPlayer;
    return RTCPlayer;
  };

  return ClientClass;
}();
var ClientAccess = /*#__PURE__*/new ( /*#__PURE__*/function () {
  function _class() {}

  var _proto2 = _class.prototype;

  _proto2.clientCb = function clientCb(cb) {
    if (this.client) cb(this.client);
  };

  _proto2.connect = function connect() {
    this.clientCb(function (cl) {
      cl.delegate.afkConnect();
    });
  };

  _proto2.close = function close() {
    this.clientCb(function (cl) {
      cl.afkLogic.closeWebSocket();
    });
  };

  _proto2.emitCommand = function emitCommand(command, value) {
    if (!this.client) return;
    Logger.verboseLog("emitCommand()\n" + JSON.stringify({
      command: command,
      value: value
    }, null, 4));
    return this.client.ueDescriptorUi.emitCommand(command, value);
  };

  _proto2.emitCommandSystem = function emitCommandSystem(command, payload) {
    if (!this.client) return;
    Logger.verboseLog("emitCommandSystem()\n" + JSON.stringify({
      command: command,
      payload: payload
    }, null, 4));
    return this.client.ueDescriptorUi.emitCommandSystem(command, payload);
  };

  _proto2.emitConsole = function emitConsole(payload) {
    if (!this.client) return;
    Logger.verboseLog("EmitConsole()\n" + JSON.stringify(payload, null, 4));
    return this.client.ueDescriptorUi.emitConsole(payload);
  } // sendEncoderSettings(payload: client.Encoder) {
  //     if (!this.client) return
  //     return this.client.iWebRTCController.sendEncoderSettings(payload)
  // }
  // sendWebRtcSettings(payload: client.WebRTC) {
  //     if (!this.client) return
  //     return this.client.iWebRTCController.sendWebRtcSettings(payload)
  // }
  ;

  _proto2.restartStreamAutomaticity = function restartStreamAutomaticity() {
    Logger.verboseLog("restartStreamAutomaticity()");
    this.clientCb(function (cl) {
      cl.iWebRTCController.restartStreamAutomaticity();
    });
  };

  _createClass(_class, [{
    key: "client",
    get: // Quck access to WebRTC object
    function get() {
      var RTCPlayer = window.RTCPlayer; // Check if WebRTC object connected

      if (!(RTCPlayer != null && RTCPlayer.ueDescriptorUi)) return null;
      return RTCPlayer;
    }
  }]);

  return _class;
}())();

var initialState = {
  commands_list: [],
  callbacks_list: [],
  config: {
    streamingUrl: null,
    secondsToKill: null,
    secondsToKillLeft: null,
    secondsToStart: null,
    autoRestart: null
  },
  psConfig: null,
  ueSettings: {
    initial: null,
    onStart: null
  },
  playerSettings: {
    volume: 1
  },
  webrtcData: {
    status: null,
    statusUpdatedAt: null,
    errorCode: null,
    autoplaySupport: null
  },
  mouseEvent: {
    moving: false
  }
};
var KEY = {
  UPDATE: 'UPDATE',
  UPDATE_CONFIG: 'UPDATE_CONFIG',
  UPDATE_PS_CONFIG: 'UPDATE_PS_CONFIG',
  UPDATE_UE_SETTINGS_INITIAL: 'UPDATE_UE_SETTINGS_INITIAL',
  UPDATE_UE_SETTINGS_ONSTART: 'UPDATE_UE_SETTINGS_ONSTART',
  UPDATE_PLAYER_SETTINGS: 'UPDATE_PLAYER_SETTINGS',
  WEBRTC_STATUS: 'WEBRTC_STATUS',
  COMMANDS_LIST: 'COMMANDS_LIST',
  CALLBACKS_LIST: 'CALLBACKS_LIST',
  COMMAND_CONFIRMATION: 'COMMAND_CONFIRMATION',
  MOUSE_EVENT: 'MOUSE_EVENT'
};

function reducer(state, action) {
  var type = action.type,
      anValue = action.payload; // console.log(state);

  if (type === KEY.UPDATE) {
    return _extends({}, state, anValue);
  } else if (type === KEY.UPDATE_CONFIG) {
    state.config = _extends({}, state.config, anValue);
    return _extends({}, state);
  } else if (type === KEY.UPDATE_PS_CONFIG) {
    state.psConfig = _extends({}, state.psConfig, anValue);
    return _extends({}, state);
  } else if (type === KEY.UPDATE_UE_SETTINGS_INITIAL) {
    state.ueSettings.initial = _extends({}, state.ueSettings.initial, anValue);
    return _extends({}, state);
  } else if (type === KEY.UPDATE_UE_SETTINGS_ONSTART) {
    state.ueSettings.onStart = _extends({}, state.ueSettings.onStart, anValue);
    return _extends({}, state);
  } else if (type === KEY.UPDATE_PLAYER_SETTINGS) {
    state.playerSettings = _extends({}, state.playerSettings, anValue);
    return _extends({}, state);
  } else if (type === KEY.WEBRTC_STATUS) {
    // Show errorCode only in cases when status is error||disconnected
    var status = EventsClass.webrtcStatusList;

    if (![status.disconnected, status.error].includes(anValue == null ? void 0 : anValue.status)) {
      anValue.errorCode = null;
    } // Checking autoplay support


    if ((anValue == null ? void 0 : anValue.status) == status.initialized_no_autoplay) {
      anValue.status = status.initialized;
      anValue.autoplaySupport = false;
    } else if ((anValue == null ? void 0 : anValue.status) == status.initialized) {
      anValue.autoplaySupport = true;
    }

    state.webrtcData = _extends({}, state.webrtcData, anValue, {
      statusUpdatedAt: moment().utc()
    });
    return _extends({}, state);
  } else if (type === KEY.COMMANDS_LIST) {
    anValue.confirmed = false;
    return eventInjection(state, 'commands_list', anValue);
  } else if (type === KEY.CALLBACKS_LIST) {
    return eventInjection(state, 'callbacks_list', anValue);
  } else if (type === KEY.COMMAND_CONFIRMATION) {
    return commandConfirmation(state, anValue);
  } else if (type === KEY.MOUSE_EVENT) {
    var key = anValue == null ? void 0 : anValue.variant;

    if (key) {
      if (key === 'moveStart') {
        state.mouseEvent.moving = true;
        return _extends({}, state);
      } else if (key === 'moveStop') {
        state.mouseEvent.moving = false;
        return _extends({}, state);
      }
    }
  }

  return state;
} // Mark command as confirmed by callback


var commandConfirmation = function commandConfirmation(state, verification_id) {
  for (var i in state.commands_list) {
    var item = state.commands_list[i];

    if ((item == null ? void 0 : item.verification_id) === verification_id) {
      state.commands_list[i].confirmed = true;
      return _extends({}, state);
    }
  }

  return state;
}; // Add item if verification_id doesnt exist in state


var eventInjection = function eventInjection(state, key, anValue) {
  var list = state[key] || []; // Dont save system commands from emitCommandSystem()

  if (!(anValue != null && anValue.verification_id) || (anValue == null ? void 0 : anValue.initiator) === 'system') {
    return state;
  }

  var allow = true;

  for (var _iterator = _createForOfIteratorHelperLoose(list), _step; !(_step = _iterator()).done;) {
    var item = _step.value;

    if (!(item != null && item.verification_id) || !(anValue != null && anValue.verification_id)) {
      allow = false;
    }

    if (item.verification_id == anValue.verification_id) {
      allow = false;
      break;
    }
  }

  if (allow) {
    var res = [anValue].concat(list).filter(function (o, index) {
      return index < 100;
    });
    state[key] = res;
    window[key] = res; // hack for emitAsyncCommand

    return _extends({}, state);
  }

  return state;
};

var parseJson = function parseJson(data) {
  try {
    return JSON.parse(data);
  } catch (err) {
    console.error('@@@cant parse json', data);
  }

  return undefined;
};

var useDispatch = function useDispatch() {
  var _React$useReducer = React.useReducer(reducer, initialState),
      state = _React$useReducer[0],
      dispatch = _React$useReducer[1];
  /**
   * Events useCallback's wrapper for state updates
   */


  var eventCommand = React.useCallback(function (_ref) {
    var detail = _ref.detail;
    var payload = parseJson(detail);
    dispatch({
      type: KEY.COMMANDS_LIST,
      payload: payload
    });
  }, [state]);
  var eventCallbacks = React.useCallback(function (_ref2) {
    var detail = _ref2.detail;
    var payload = parseJson(detail);
    cls.commandConfirmation(payload == null ? void 0 : payload.verification_id);
    dispatch({
      type: KEY.CALLBACKS_LIST,
      payload: payload
    });
  }, [state]);
  var eventMouse = React.useCallback(function (_ref3) {
    var detail = _ref3.detail;
    var payload = detail;
    dispatch({
      type: KEY.MOUSE_EVENT,
      payload: payload
    });
  }, [state]);
  var eventWebrtcStatus = React.useCallback(function (_ref4) {
    var detail = _ref4.detail;
    cls.updateWebrtcData(detail);
  }, [state]);
  var eventUeSettingsInitial = React.useCallback(function (_ref5) {
    var detail = _ref5.detail;
    var payload = detail;
    dispatch({
      type: KEY.UPDATE_UE_SETTINGS_INITIAL,
      payload: payload
    });
  }, [dispatch]);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.update = function update(payload) {
      dispatch({
        type: KEY.UPDATE,
        payload: payload
      });
    };

    _proto.updateConfig = function updateConfig(payload) {
      dispatch({
        type: KEY.UPDATE_CONFIG,
        payload: payload
      });
    };

    _proto.updatePsConfig = function updatePsConfig(payload) {
      dispatch({
        type: KEY.UPDATE_PS_CONFIG,
        payload: payload
      });
    };

    _proto.updateUeSettingsOnStart = function updateUeSettingsOnStart(payload) {
      dispatch({
        type: KEY.UPDATE_UE_SETTINGS_ONSTART,
        payload: payload
      });
    };

    _proto.updatePlayerSettings = function updatePlayerSettings(payload) {
      dispatch({
        type: KEY.UPDATE_PLAYER_SETTINGS,
        payload: payload
      });
    };

    _proto.commandConfirmation = function commandConfirmation(payload) {
      dispatch({
        type: KEY.COMMAND_CONFIRMATION,
        payload: payload
      });
    };

    _proto.updateWebrtcData = function updateWebrtcData(payload) {
      dispatch({
        type: KEY.WEBRTC_STATUS,
        payload: payload
      });
    };

    return _class;
  }())();
  var eventHandler = {
    eventCommand: eventCommand,
    eventCallbacks: eventCallbacks,
    eventMouse: eventMouse,
    eventWebrtcStatus: eventWebrtcStatus,
    eventUeSettingsInitial: eventUeSettingsInitial
  };
  return [state, cls, eventHandler];
};

var initialState$1 = {
  apiKey: null,
  buildId: null,
  devBar: {
    slug: null
  },
  sessionData: null,
  metaData: null,
  metaConfig: {
    showToolbar: true,
    showQuickMenu: false,
    showDevBar: true,
    showOverlay: true,
    notifications: {
      showCommands: true,
      showCallbacks: true,
      placement: 'topStart'
    },
    videoUrl: null,
    issuesUrl: null
  }
};
var KEY$1 = {
  UPDATE: 'UPDATE',
  UPDATE_DEVBAR: 'UPDATE_DEVBAR',
  UPDATE_METACONFIG: 'UPDATE_METACONFIG',
  UPDATE_NOTIFICATION_SETTINGS: 'UPDATE_NOTIFICATION_SETTINGS',
  UPDATE_SESSION_DATA: 'UPDATE_SESSION_DATA'
};

var reducer$1 = function reducer(state, action) {
  var type = action.type,
      anValue = action.payload; // console.log(state);

  if (type === KEY$1.UPDATE) {
    return _extends({}, state, anValue);
  } else if (type === KEY$1.UPDATE_DEVBAR) {
    state.devBar = _extends({}, state.devBar, anValue);
    return _extends({}, state);
  } else if (type === KEY$1.UPDATE_METACONFIG) {
    state.metaConfig = _extends({}, state.metaConfig, anValue);
    return _extends({}, state);
  } else if (type === KEY$1.UPDATE_NOTIFICATION_SETTINGS) {
    state.metaConfig.notifications = _extends({}, state.metaConfig.notifications, anValue);
    return _extends({}, state);
  } else if (type === KEY$1.UPDATE_SESSION_DATA) {
    state.sessionData = _extends({}, state.sessionData, anValue);
    return _extends({}, state);
  }

  return state;
};

var useDispatch$1 = function useDispatch() {
  var _React$useReducer = React.useReducer(reducer$1, initialState$1),
      state = _React$useReducer[0],
      dispatch = _React$useReducer[1];

  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.update = function update(payload) {
      dispatch({
        type: KEY$1.UPDATE,
        payload: payload
      });
    };

    _proto.updateDevBar = function updateDevBar(payload) {
      dispatch({
        type: KEY$1.UPDATE_DEVBAR,
        payload: payload
      });
    };

    _proto.updateMetaConfig = function updateMetaConfig(payload) {
      dispatch({
        type: KEY$1.UPDATE_METACONFIG,
        payload: payload
      });
    };

    _proto.updateNotificationSettings = function updateNotificationSettings(payload) {
      dispatch({
        type: KEY$1.UPDATE_NOTIFICATION_SETTINGS,
        payload: payload
      });
    };

    _proto.updateSessionData = function updateSessionData(payload) {
      dispatch({
        type: KEY$1.UPDATE_SESSION_DATA,
        payload: payload
      });
    };

    return _class;
  }())();
  return [state, cls];
};

var name = "pixel-streaming";
var version = "3.3.6";
var author = "MetaEditor";
var license = "MIT";
var description = "MetaEditor — ReactJS Pixel Streaming library, helps integrate Unreal Engine v.5 in the browser. Allows you to send commands and get callbacks from the stream server with launched Unreal Engine.";
var keywords = [
	"reactjs",
	"node",
	"typescript",
	"pixel streaming",
	"unreal engine",
	"epic games",
	"metaverse",
	"metaeditor",
	"unrealos"
];
var homepage = "https://metaeditor.io/";
var repository = {
	type: "git",
	url: "git+https://github.com/markolofsen/metaeditor.git"
};
var bugs = {
	url: "https://github.com/markolofsen/metaeditor/issues"
};
var main = "dist/index.js";
var typings = "dist/index.d.ts";
var files = [
	"dist",
	"src"
];
var engines = {
	node: ">=v16"
};
var scripts = {
	"copy-files": "copyfiles -u 1 src/styles/*.css dist/",
	dev: "tsdx watch NODE_ENV=development",
	start: "tsdx watch",
	build: "tsdx build --transpileOnly && pnpm copy-files",
	test: "tsdx test",
	lint: "tsdx lint",
	prepare: "tsdx build"
};
var husky = {
	hooks: {
		"pre-commit": "tsdx lint"
	}
};
var prettier = {
	printWidth: 80,
	semi: false,
	singleQuote: false,
	trailingComma: "es5"
};
var module$1 = "dist/index.esm.js";
var peerDependencies = {
	react: "^18.1.0",
	rsuite: "^5.12.0"
};
var dependencies = {
	"@fortawesome/fontawesome-svg-core": "latest",
	"@fortawesome/free-solid-svg-icons": "latest",
	"@fortawesome/react-fontawesome": "latest",
	"@rsuite/icons": "^1.0.2",
	"@types/url-parse": "1.4.8",
	moment: "latest",
	"react-hotkeys-hook": "^3.4.4",
	"react-json-view": "^1.21.3",
	"react-jss": "^10.9.0",
	"url-parse": "^1.5.10",
	"react-qr-code": "^2.0.5",
	"unreal-pixel-streaming": "1.1.0"
};
var devDependencies = {
	"@testing-library/jest-dom": "^5.16.4",
	"@testing-library/react": "^13.2.0",
	"@testing-library/user-event": "^13.5.0",
	"@typescript-eslint/eslint-plugin": "^5.16.0",
	"@typescript-eslint/parser": "^5.16.0",
	copyfiles: "^2.4.1",
	eslint: "^8.11.0",
	husky: "^7.0.2",
	"react-scripts": "5.0.1",
	rsuite: "^5.12.0",
	tsdx: "^0.14.1",
	tslib: "^2.3.1",
	typescript: "^4.6.3"
};
var packageJson = {
	name: name,
	version: version,
	author: author,
	license: license,
	description: description,
	keywords: keywords,
	homepage: homepage,
	repository: repository,
	bugs: bugs,
	main: main,
	typings: typings,
	files: files,
	engines: engines,
	scripts: scripts,
	husky: husky,
	prettier: prettier,
	module: module$1,
	peerDependencies: peerDependencies,
	dependencies: dependencies,
	devDependencies: devDependencies
};

var config = /*#__PURE__*/new ( /*#__PURE__*/function () {
  function _class() {
    this.isDev = "development" === 'development';
    this.version = packageJson.version;
    this.systemName = 'MetaEditor';
    this.websiteUrl = 'https://metaeditor.io';
    this.apiUrl = 'https://api.metaeditor.io';

    this.portalUrl = 'https://portal.metaeditor.io';
    this.updateUrl = 'https://metaeditor.io/docs/pixel-streaming/settings/update';
  }

  _createClass(_class, [{
    key: "portal",
    get: function get() {
      var url_parsed = parse(this.portalUrl, true);
      return {
        name: url_parsed.hostname,
        url: this.portalUrl,
        urlProjects: this.portalUrl + '/user/projects/'
      };
    }
  }]);

  return _class;
}())();

var Request = /*#__PURE__*/new ( /*#__PURE__*/function () {
  function _class() {}

  var _proto = _class.prototype;

  _proto.urlBuilder = function urlBuilder(route) {
    return config.apiUrl + "/api" + route;
  };

  _proto.request = /*#__PURE__*/function () {
    var _request = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(method, url, getOptions) {
      var options, response, responseJson;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (getOptions === void 0) {
                getOptions = {};
              }

              url = this.urlBuilder(url);
              options = _extends({
                method: method,
                mode: 'cors'
              }, getOptions);
              options.headers = new Headers(_extends({}, options.headers, {
                'Origin': '',
                'Accept': 'application/json',
                'Content-Type': 'application/json'
              })); // body preparations

              if (method === 'POST' && options.body) {
                try {
                  options.body = JSON.stringify(options.body);
                } catch (err) {
                  console.error('Request', {
                    method: method,
                    err: err
                  });
                }
              }

              _context.prev = 5;
              _context.next = 8;
              return fetch(url, options);

            case 8:
              response = _context.sent;
              _context.next = 11;
              return response.json();

            case 11:
              responseJson = _context.sent;
              return _context.abrupt("return", {
                ok: response.status === 200,
                status: response.status,
                body: responseJson
              });

            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](5);
              console.error('Request', {
                error: _context.t0
              });
              return _context.abrupt("return", {
                status: 0,
                error: _context.t0
              });

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[5, 15]]);
    }));

    function request(_x, _x2, _x3) {
      return _request.apply(this, arguments);
    }

    return request;
  }();

  _proto.GET = /*#__PURE__*/function () {
    var _GET = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, options) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.request('GET', url, options);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function GET(_x4, _x5) {
      return _GET.apply(this, arguments);
    }

    return GET;
  }();

  _proto.POST = /*#__PURE__*/function () {
    var _POST = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(url, body, options) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.request('POST', url, _extends({
                body: body
              }, options));

            case 2:
              return _context3.abrupt("return", _context3.sent);

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function POST(_x6, _x7, _x8) {
      return _POST.apply(this, arguments);
    }

    return POST;
  }();

  _proto.DELETE = /*#__PURE__*/function () {
    var _DELETE = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url, options) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.request('DELETE', url, options);

            case 2:
              return _context4.abrupt("return", _context4.sent);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function DELETE(_x9, _x10) {
      return _DELETE.apply(this, arguments);
    }

    return DELETE;
  }();

  return _class;
}())();

// hooks
var useApi = function useApi() {
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.sessionRead = function sessionRead(sessionUuid) {
      return Request.GET('/streams_provider/session/read/' + sessionUuid);
    };

    _proto.sessionCreate = function sessionCreate(build_id) {
      return Request.POST('/streams_provider/session/create/', {
        build_id: build_id
      });
    };

    _proto.getMetaeditorData = function getMetaeditorData(apiKey) {
      var headers = {
        'x-metaeditor-apikey': apiKey
      };
      return Request.GET('/info/metaeditor/', {
        headers: headers
      });
    };

    return _class;
  }())();
  return cls;
};

var useEventListener = function useEventListener(eventName, handler, element) {
  if (element === void 0) {
    element = document;
  }

  // Create a ref that stores handler
  var savedHandler = React.useRef(); // Update ref.current value if handler changes.
  // This allows our effect below to always get latest handler ...
  // ... without us needing to pass it in effect deps array ...
  // ... and potentially cause effect to re-run every render.

  React.useEffect(function () {
    savedHandler.current = handler;
  }, [handler]);
  React.useEffect(function () {
    // Make sure element supports addEventListener
    // On
    var isSupported = element && element.addEventListener;
    if (!isSupported) return; // Create event listener that calls handler function stored in ref

    var eventListener = function eventListener(event) {
      return savedHandler.current(event);
    }; // Add event listener


    element.addEventListener(eventName, eventListener); // Remove event listener on cleanup

    return function () {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element] // Re-run if eventName or element changes
  );
};

// type StorageType = 'session' | 'local';
// type UseStorageReturnValue = {
//   getItem: (key: string, type?: StorageType) => string;
//   setItem: (key: string, value: string, type?: StorageType) => boolean;
//   removeItem: (key: string, type?: StorageType) => void;
// };
var useStorage = function useStorage() {
  var storageType = function storageType(type) {
    return (type != null ? type : 'session') + "Storage";
  };

  var isBrowser = typeof window !== 'undefined';

  var getItem = function getItem(key, type) {
    var value = window[storageType(type)][key]; // If value is object

    try {
      value = JSON.parse(value);
    } catch (err) {}

    return isBrowser ? value : '';
  };

  var setItem = function setItem(key, value, type) {
    if (isBrowser) {
      // If value is object
      if (typeof value === 'object') {
        try {
          value = JSON.stringify(value);
        } catch (err) {
          console.error('Can\'t serialize data', err);
        }
      }

      window[storageType(type)].setItem(key, value);
      return true;
    }

    return false;
  };

  var removeItem = function removeItem(key, type) {
    window[storageType(type)].removeItem(key);
  };

  var wrapper = function wrapper(STORAGE_KEY, type) {
    return {
      read: function () {
        var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cb) {
          var stored_data;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return getItem(STORAGE_KEY, type);

                case 2:
                  stored_data = _context.sent;

                  if (!(typeof cb === 'function')) {
                    _context.next = 6;
                    break;
                  }

                  cb(stored_data || null);
                  return _context.abrupt("return", stored_data);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function read(_x) {
          return _read.apply(this, arguments);
        }

        return read;
      }(),
      save: function save(data) {
        setItem(STORAGE_KEY, data, type);
      },
      remove: function remove() {
        removeItem(STORAGE_KEY, type);
      }
    };
  };

  return {
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    wrapper: wrapper
  };
};

var useStorageBook = function useStorageBook() {
  var storage = useStorage();
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    _createClass(_class, [{
      key: "apiKey",
      get: function get() {
        return storage.wrapper('API_KEY', 'local');
      }
    }, {
      key: "sessionUuid",
      get: function get() {
        return storage.wrapper('SESSION_UUID', 'session');
      }
    }]);

    return _class;
  }())();
  return cls;
};

var API_INTERVAL_SEC = 3;
var useBuildConnector = function useBuildConnector(dispatch) {
  var api = useApi();
  var storageBook = useStorageBook();
  var refInterval = React.useRef(null);

  var _React$useState = React.useState(false),
      buildId = _React$useState[0],
      setBuildId = _React$useState[1];

  var _React$useState2 = React.useState(false),
      sessionUuid = _React$useState2[0],
      setSessionUuid = _React$useState2[1];

  React.useEffect(function () {
    return function () {
      clearInterval(refInterval.current);
    };
  }, []);
  React.useEffect(function () {
    if (sessionUuid) {
      clearInterval(refInterval.current);
      cls.readSessionData();
      refInterval.current = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return cls.readSessionData();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), 1000 * API_INTERVAL_SEC);
    }
  }, [sessionUuid]);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.start = /*#__PURE__*/function () {
      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(buildId) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                setBuildId(buildId);

                if (this.urlSessionExist) {
                  _context2.next = 4;
                  break;
                }

                _context2.next = 4;
                return this.waitSessionData(buildId);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function start(_x) {
        return _start.apply(this, arguments);
      }

      return start;
    }();

    _proto.waitSessionData = /*#__PURE__*/function () {
      var _waitSessionData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(buildId) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                storageBook.sessionUuid.read(function (res) {
                  if (res) {
                    setSessionUuid(res);
                    return;
                  }
                });
                _context4.next = 3;
                return api.sessionCreate(buildId).then( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(res) {
                    var uuid;
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (res.ok) {
                              uuid = res.body.uuid;

                              if (uuid) {
                                setSessionUuid(uuid);
                                storageBook.sessionUuid.save(uuid);
                              }
                            }

                            return _context3.abrupt("return", false);

                          case 2:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x3) {
                    return _ref2.apply(this, arguments);
                  };
                }())["catch"](function (err) {
                  throw new Error(err);
                });

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function waitSessionData(_x2) {
        return _waitSessionData.apply(this, arguments);
      }

      return waitSessionData;
    }();

    _proto.removeSession = function removeSession() {
      client.Logger.infoLog('Remove session & reinit');
      setSessionUuid(false);
      storageBook.sessionUuid.remove();
      clearInterval(refInterval.current);
      this.waitSessionData(buildId);
    };

    _proto.readSessionData = /*#__PURE__*/function () {
      var _readSessionData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this = this;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return api.sessionRead(sessionUuid).then(function (res) {
                  if (res.ok) {
                    var _sessionData$metadata;

                    var stream_data = res.body.stream_data; // const { host, port, que, seconds_to_kill, seconds_to_start, status } = stream_data
                    // const streamingUrl = stream_data.host
                    // const secondsToStart = stream_data.seconds_to_start
                    // const secondsToKill = stream_data.seconds_to_kill

                    var status = stream_data.status; // console.log('@@status', status)
                    // console.log('@@secondsToStart', secondsToStart)

                    var sessionData = res.body;
                    var apiKey = (_sessionData$metadata = sessionData.metadata) == null ? void 0 : _sessionData$metadata.api_key;

                    if (apiKey) {
                      dispatch.update({
                        apiKey: apiKey
                      });
                    }

                    dispatch.updateSessionData(sessionData);

                    if (status === 'active') {
                      clearInterval(refInterval.current);
                    }
                  } else {
                    _this.removeSession();
                  }
                })["catch"](function (err) {
                  throw new Error(err);
                });

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function readSessionData() {
        return _readSessionData.apply(this, arguments);
      }

      return readSessionData;
    }();

    _createClass(_class, [{
      key: "urlSessionExist",
      get: function get() {
        var params = decodeURI(window.location.search).replace('?', '').split('&').map(function (param) {
          return param.split('=');
        }).reduce(function (values, _ref3) {
          var key = _ref3[0],
              value = _ref3[1];
          values[key] = value;
          return values;
        }, {});

        if (params != null && params.session) {
          setSessionUuid(params.session);
          storageBook.sessionUuid.save(params.session);
          return true;
        }

        return false;
      }
    }]);

    return _class;
  }())();
  return cls;
};

// config
var useVersionCompare = function useVersionCompare() {
  var compare = function compare(a, b) {
    if (a === b) {
      return 0;
    }

    var a_components = a.split('.');
    var b_components = b.split('.');
    var len = Math.min(a_components.length, b_components.length); // loop while the components are equal

    for (var i = 0; i < len; i++) {
      // A bigger than B
      if (parseInt(a_components[i]) > parseInt(b_components[i])) {
        return 1;
      } // B bigger than A


      if (parseInt(a_components[i]) < parseInt(b_components[i])) {
        return -1;
      }
    } // If one's a prefix of the other, the longer one is greater.


    if (a_components.length > b_components.length) {
      return 1;
    }

    if (a_components.length < b_components.length) {
      return -1;
    } // Otherwise they are the same.


    return 0;
  };

  var result = function result(current, release) {
    var transform = function transform(v) {
      return v.match(/\d+/g).join('.');
    };

    current = transform(current);
    release = transform(release);
    var status = compare(current, release);
    return {
      current: current,
      release: release,
      status: status,
      update: status < 0
    };
  };

  return function (release) {
    return result(config.version, release);
  };
};

// import JsonViewer from '../../../components/JsonViewer'

var useNotifier = function useNotifier() {
  var refCommand = React.useRef(null);
  var refCallback = React.useRef(null);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    // Hide system messages
    _proto.restricted = function restricted(payload) {
      if (['browser', 'ue'].includes(payload == null ? void 0 : payload.initiator)) {
        return false;
      }

      return true;
    };

    _proto.getValue = function getValue(detail) {
      try {
        return JSON.parse(detail);
      } catch (err) {
        console.error('@@@Cant parse event', {
          detail: detail
        });
      }
    };

    _proto.pushCommand = function pushCommand(placement, event) {
      var payload = this.getValue(event.detail);
      if (this.restricted(payload)) return;
      var message = React.createElement(Notification, {
        type: undefined,
        header: payload == null ? void 0 : payload.command,
        closable: true
      }); // toaster.remove(refCommand.current)

      refCommand.current = toaster.push(message, {
        placement: placement
      });
    };

    _proto.pushCallback = function pushCallback(placement, event) {
      var payload = this.getValue(event.detail);
      if (this.restricted(payload)) return;
      var message = React.createElement(Notification, {
        type: 'success',
        header: payload == null ? void 0 : payload.command,
        closable: true
      });
      refCallback.current = toaster.push(message, {
        placement: placement
      });
    };

    return _class;
  }())();
  return cls;
};

var useActions = function useActions() {
  var _useDispatch = useDispatch$1(),
      state = _useDispatch[0],
      dispatch = _useDispatch[1];

  var api = useApi();
  var notifier = useNotifier();
  var storageBook = useStorageBook();
  var versionCompare = useVersionCompare(); // Fetch streaming session by buildId

  var buildConnector = useBuildConnector(dispatch); // Notification settings

  useEventListener(EventsClass.commands.key, function (payload) {
    if (!notifications.showCommands) return;
    notifier.pushCommand(notifications.placementValue, payload);
  });
  useEventListener(EventsClass.callbacks.key, function (payload) {
    if (!notifications.showCallbacks) return;
    notifier.pushCallback(notifications.placementValue, payload);
  });
  /**
   * First initialization
   */

  React.useEffect(function () {
    // Load data by Api Key
    storageBook.apiKey.read(function (v) {
      if (v) cls.loadData(v);
    });
  }, []);
  /**
   * loadData if apiKey applied
   */

  React.useEffect(function () {
    if (state.apiKey) {
      cls.loadData();
    }
  }, [state.apiKey]);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.initMetaConfig = function initMetaConfig(payload) {
      dispatch.updateMetaConfig(payload);
    };

    _proto.setApiKey = function setApiKey(apiKey) {
      dispatch.update({
        apiKey: apiKey
      });
    };

    _proto.loadData = /*#__PURE__*/function () {
      var _loadData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(apiKey) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (apiKey === void 0) {
                  apiKey = state.apiKey;
                }

                _context.next = 3;
                return api.getMetaeditorData(apiKey).then(function (res) {
                  if (res.ok) {
                    var metaData = res.body;
                    dispatch.update({
                      metaData: metaData
                    });
                    storageBook.apiKey.save(apiKey);
                    return true;
                  } else {
                    dispatch.update({
                      apiKey: null
                    });
                    storageBook.apiKey.remove();
                  }

                  return false;
                });

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function loadData(_x) {
        return _loadData.apply(this, arguments);
      }

      return loadData;
    }();

    _proto.connectBuild = function connectBuild(buildId) {
      dispatch.update({
        buildId: buildId
      });
      buildConnector.start(buildId);
    };

    _createClass(_class, [{
      key: "apiKeyIsCorrect",
      get: function get() {
        return state.apiKey ? true : false;
      }
    }, {
      key: "commands_system",
      get: function get() {
        var _state$metaData;

        var list = (_state$metaData = state.metaData) == null ? void 0 : _state$metaData.commands_system;
        if (!Array.isArray(list)) return [];
        return list;
      }
    }, {
      key: "commands_project",
      get: function get() {
        var _state$metaData2;

        var list = (_state$metaData2 = state.metaData) == null ? void 0 : _state$metaData2.commands_project;
        if (!Array.isArray(list)) return [];
        return list;
      }
    }, {
      key: "streamingUrl",
      get: function get() {
        if (this.sessionData) {
          return this.sessionData.streamingUrl;
        }

        return false;
      }
    }, {
      key: "sharedUrl",
      get: function get() {
        var _this$sessionData;

        if (!this.sessionData) return false;
        var sessionUuid = (_this$sessionData = this.sessionData) == null ? void 0 : _this$sessionData.uuid;
        var _document$location = document.location,
            protocol = _document$location.protocol,
            host = _document$location.host,
            pathname = _document$location.pathname;
        return protocol + "//" + host + pathname + "?session=" + sessionUuid;
      }
    }, {
      key: "sessionData",
      get: function get() {
        if (state.sessionData) {
          var _state$sessionData = state.sessionData,
              stream_data = _state$sessionData.stream_data,
              uuid = _state$sessionData.uuid;
          return {
            uuid: uuid,
            streamingUrl: stream_data.host,
            status: stream_data.status,
            secondsToStart: stream_data.seconds_to_start
          };
        }

        return false;
      }
    }, {
      key: "apiData",
      get: function get() {
        if (state.sessionData) {
          var _state$metaData3;

          var _state$metaData$api_d = (_state$metaData3 = state.metaData) == null ? void 0 : _state$metaData3.api_data,
              error = _state$metaData$api_d.error,
              module_version = _state$metaData$api_d.module_version;

          return {
            error: error,
            module: versionCompare(module_version)
          };
        }

        return false;
      }
    }]);

    return _class;
  }())();
  var project = new ( /*#__PURE__*/function () {
    function _class2() {}

    _createClass(_class2, [{
      key: "exist",
      get: function get() {
        return state.metaData ? true : false;
      }
    }, {
      key: "name",
      get: function get() {
        var _state$metaData4, _state$metaData4$proj, _state$metaData4$proj2;

        return (_state$metaData4 = state.metaData) == null ? void 0 : (_state$metaData4$proj = _state$metaData4.project) == null ? void 0 : (_state$metaData4$proj2 = _state$metaData4$proj.info) == null ? void 0 : _state$metaData4$proj2.name;
      }
    }, {
      key: "menu",
      get: function get() {
        var _state$metaData5;

        return ((_state$metaData5 = state.metaData) == null ? void 0 : _state$metaData5.menu) || [];
      }
    }, {
      key: "config",
      get: function get() {
        var _state$metaData6, _state$metaData6$proj, _state$metaData6$proj2;

        return ((_state$metaData6 = state.metaData) == null ? void 0 : (_state$metaData6$proj = _state$metaData6.project) == null ? void 0 : (_state$metaData6$proj2 = _state$metaData6$proj.info) == null ? void 0 : _state$metaData6$proj2.config) || false;
      }
    }]);

    return _class2;
  }())();
  var config = new ( /*#__PURE__*/function () {
    function _class3() {}

    _createClass(_class3, [{
      key: "showToolbar",
      get: function get() {
        return state.metaConfig.showToolbar;
      }
    }, {
      key: "showQuickMenu",
      get: function get() {
        return state.metaConfig.showQuickMenu;
      }
    }, {
      key: "showDevBar",
      get: function get() {
        return state.metaConfig.showDevBar;
      }
    }, {
      key: "helpers",
      get: function get() {
        return {
          keyboard: state.metaConfig.helpers.keyboard
        };
      }
    }, {
      key: "showOverlay",
      get: function get() {
        return state.metaConfig.showOverlay;
      }
    }, {
      key: "issuesUrl",
      get: function get() {
        return state.metaConfig.issuesUrl;
      }
    }, {
      key: "videoUrl",
      get: function get() {
        var _state$sessionData2, _state$sessionData2$m;

        return ((_state$sessionData2 = state.sessionData) == null ? void 0 : (_state$sessionData2$m = _state$sessionData2.metadata) == null ? void 0 : _state$sessionData2$m.video_url) || state.metaConfig.videoUrl;
      }
    }]);

    return _class3;
  }())();
  var notifications = new ( /*#__PURE__*/function () {
    function _class4() {}

    var _proto2 = _class4.prototype;

    _proto2.updatePlacement = function updatePlacement(placement) {
      dispatch.updateNotificationSettings({
        placement: placement
      });
    };

    _proto2.updateCommands = function updateCommands(showCommands) {
      dispatch.updateNotificationSettings({
        showCommands: showCommands
      });
    };

    _proto2.updateCallbacks = function updateCallbacks(showCallbacks) {
      dispatch.updateNotificationSettings({
        showCallbacks: showCallbacks
      });
    };

    _createClass(_class4, [{
      key: "showCommands",
      get: function get() {
        return state.metaConfig.notifications.showCommands;
      }
    }, {
      key: "showCallbacks",
      get: function get() {
        return state.metaConfig.notifications.showCallbacks;
      }
    }, {
      key: "placementsList",
      get: function get() {
        return [{
          label: 'topStart',
          value: 'topStart'
        }, {
          label: 'topCenter',
          value: 'topCenter'
        }, {
          label: 'topEnd',
          value: 'topEnd'
        }, {
          label: 'bottomStart',
          value: 'bottomStart'
        }, {
          label: 'bottomCenter',
          value: 'bottomCenter'
        }, {
          label: 'bottomEnd',
          value: 'bottomEnd'
        }];
      }
    }, {
      key: "placementValue",
      get: function get() {
        return state.metaConfig.notifications.placement;
      }
    }]);

    return _class4;
  }())();
  return {
    state: state,
    dispatch: dispatch,
    cls: cls,
    config: config,
    project: project,
    notifications: notifications
  };
};

var AppContext = /*#__PURE__*/React.createContext({});
var useSystem = function useSystem() {
  return React.useContext(AppContext);
}; // classes

var Provider = function Provider(props) {
  var actions = useActions();
  return React.createElement(AppContext.Provider, {
    value: actions
  }, props.children);
};

var useResolution = function useResolution(ConsoleSettings) {
  var refTimer = React.useRef(null); // Initialize state with undefined width/height so server and client renders match

  var _React$useState = React.useState({
    width: 0,
    height: 0
  }),
      setState = _React$useState[1]; // Handler to call on window resize


  var handleResize = function handleResize() {
    // Set window width/height to state
    var width = window.innerWidth;
    var height = window.innerHeight;
    setState({
      width: width,
      height: height
    }); // Set for css

    var doc = document.documentElement;
    doc.style.setProperty("--window-width", window.innerWidth + 'px');
    doc.style.setProperty("--window-height", window.innerHeight + 'px'); // Set object-fit for player dependes on highest resolution side

    var objectFit = width > height ? 'unset' : 'fill';
    doc.style.setProperty("--player-object-fit", objectFit); // Update resolution of pixel-streaming

    cls.updateWebrtcResolution(width, height);
  };

  useEventListener('resize', handleResize, window);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    // will be called after the stream activation
    _proto.resize = function resize() {
      handleResize();
    } // screen resolution options
    ;

    _proto.updateWebrtcResolution =
    /*#__PURE__*/
    function () {
      var _updateWebrtcResolution = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(width, height) {
        var emitConsole, emitCmd;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                clearTimeout(refTimer.current);

                emitConsole = function emitConsole(payload) {
                  return ClientAccess.emitConsole(payload);
                };

                emitCmd = function emitCmd(command, payload) {
                  return ClientAccess.emitCommandSystem(command, payload);
                };

                refTimer.current = setTimeout(function () {
                  // https://docs.unrealengine.com/5.0/en-US/unreal-engine-pixel-streaming-reference/
                  // if (ui) ui.sendEncoderMinQP(-1)
                  // emitCons('PixelStreaming.Encoder.MinQP -1')
                  // emitCons('PixelStreaming.WebRTC.StartBitrate 20000000')
                  // emitCons('PixelStreaming.Encoder.RateControl ConstQP')
                  var RTCPlayer = ClientAccess.client;
                  if (!ConsoleSettings) return; // Whether to hide the UE application cursor.

                  if (typeof ConsoleSettings.cursor === 'boolean') {
                    emitConsole("PixelStreaming.HudStats " + ConsoleSettings.cursor.toString());
                  } // Whether to show PixelStreaming stats on the in-game HUD.


                  if (typeof ConsoleSettings.hudSats === 'boolean') {
                    emitConsole("PixelStreaming.HudStats " + ConsoleSettings.hudSats.toString());
                  }

                  switch (ConsoleSettings.mode) {
                    // Set resolution to metaplugin
                    case 'command':
                      emitCmd('resolution_change', {
                        width: width,
                        height: height
                      });
                      break;
                    // Set resolution by native console method

                    case 'console':
                      if (RTCPlayer) {
                        RTCPlayer.ueDescriptorUi.sendUpdateVideoStreamSize(width, height);
                      } // emitConsole(`r.SetRes ${width}x${height}f`)
                      // emitConsole('PixelStreaming.Capturer.UseBackBufferSize 0')
                      // emitConsole(`PixelStreaming.Capturer.CaptureSize ${width}x${height}`)


                      break;
                  }
                }, 500);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function updateWebrtcResolution(_x, _x2) {
        return _updateWebrtcResolution.apply(this, arguments);
      }

      return updateWebrtcResolution;
    }();

    return _class;
  }())();
  return cls;
};

/*
Usage:

// hooks
import {useUnload} from 'hooks/'


const MyComponent = () => {
  useUnload(e => {
    e.preventDefault();
    e.returnValue = '';
  });

  return (
    <div>
      Some content
    </div>
  );
};

*/
var useUnload = function useUnload(fn) {
  var cb = React.useRef(fn); // init with fn, so that type checkers won't assume that current might be undefined

  React.useEffect(function () {
    cb.current = fn;
  }, [fn]);

  var onUnload = function onUnload() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return cb.current == null ? void 0 : cb.current.apply(cb, args);
  };

  React.useEffect(function () {
    return function () {
      cls.deactivate();
    };
  }, []);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.activate = function activate() {
      window.addEventListener("beforeunload", onUnload);
    };

    _proto.deactivate = function deactivate() {
      window.removeEventListener("beforeunload", onUnload);
    };

    return _class;
  }())();
  return cls;
};

var useCountdown = function useCountdown() {
  var refInterval = React.useRef(null);

  var _React$useState = React.useState({
    active: false,
    percent: 0,
    leftSeconds: 0
  }),
      data = _React$useState[0],
      setData = _React$useState[1];

  React.useEffect(function () {
    return function () {
      cls.stop();
    };
  }, []); // React.useEffect(() => {
  //   if (data.active && data.percent > 0) {
  //     Logger.infoLog('Countdown: ' + data.percent);
  //   }
  // }, [data.percent])

  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.stop = function stop() {
      setData({
        active: false,
        percent: 0,
        leftSeconds: 0
      });
      clearInterval(refInterval.current);
    };

    _proto.start = function start(seconds) {
      if (typeof seconds !== 'number' || seconds < 0) return;
      if (data.active) return;
      var startTime = moment();
      var targetTime = startTime.add(seconds, 'seconds');
      clearInterval(refInterval.current);
      refInterval.current = setInterval(function () {
        var totalSeconds = seconds;
        var leftSeconds = moment.duration(targetTime.diff(moment())).asSeconds();

        var relDiff = function relDiff(a, b) {
          return Math.round((a - b) / a * 100);
        };

        var percent = relDiff(totalSeconds, leftSeconds);

        if (percent >= 100) {
          clearInterval(refInterval.current);
          setData({
            active: false,
            percent: 100,
            leftSeconds: 0
          });
          return;
        }

        setData({
          active: true,
          percent: percent,
          leftSeconds: leftSeconds
        });
      }, 100);
    };

    _createClass(_class, [{
      key: "active",
      get: function get() {
        return data.active;
      }
    }, {
      key: "percent",
      get: function get() {
        return data.percent;
      }
    }, {
      key: "leftSeconds",
      get: function get() {
        return data.leftSeconds;
      }
    }, {
      key: "time",
      get: function get() {
        var sec = data.leftSeconds;
        return moment.utc(sec * 1000).format('mm:ss');
      }
    }]);

    return _class;
  }())();
  return cls;
};

var useStreamKiller = function useStreamKiller(dispatch, streamingActive, config) {
  var secondsToKill = Math.round(config.secondsToKill);
  var refTimer = React.useRef(null);
  var refInterval = React.useRef(null);
  var refIntervalSec = React.useRef(0);
  React.useEffect(function () {
    return function () {
      handleStop();
    };
  }, []);

  var handleStop = function handleStop() {
    clearTimeout(refInterval.current);
    clearTimeout(refTimer.current);
    dispatch.updateConfig({
      secondsToKillLeft: null
    });
  }; // Initialization when streaming is active and secondsToKill > 0


  React.useEffect(function () {
    if (typeof secondsToKill !== 'number' || secondsToKill <= 0) return;

    if (streamingActive) {
      if (typeof secondsToKill === 'number' && secondsToKill > 0) {
        clearTimeout(refTimer.current);
        clearInterval(refInterval.current);
        refIntervalSec.current = Math.round(secondsToKill);
        refInterval.current = setInterval(function () {
          refIntervalSec.current -= 1;
          dispatch.updateConfig({
            secondsToKillLeft: refIntervalSec.current
          }); // Logger.verboseLog('Seconds to kill: ' + refIntervalSec.current);
        }, 1000);
        refTimer.current = setTimeout(function () {
          clearInterval(refInterval.current);
          Logger.verboseLog('Connection killed');
          ClientAccess.close();
        }, 1000 * secondsToKill);
      }
    } else {
      handleStop();
    }
  }, [config.secondsToKill, streamingActive]);
};

var useUnrealSettings = function useUnrealSettings(state, active) {
  React.useEffect(function () {
    var _state$ueSettings;

    if (!active) return; // const encoderSettings = {
    //   TargetBitrate: -1,
    //   MaxBitrate: 20000000,
    //   MinQP: 0, //-1
    //   MaxQP: 51, //-1
    //   RateControl: 'CBR', //"CBR" | "VBR" | "ConstQP"
    //   FillerData: 0,
    //   MultiPass: 'FULL', //"DISABLED" | "QUARTER" | "FULL";
    // }
    // const webrtcSettings = {
    //   DegradationPref: 'MAINTAIN_FRAMERATE', //"BALANCED" | "MAINTAIN_FRAMERATE" | "MAINTAIN_RESOLUTION";
    //   MinBitrate: 100000,
    //   MaxBitrate: 20000000,
    //   LowQP: 25,
    //   HighQP: 37,
    //   MaxFPS: 60,
    //   FPS: 60,
    // }

    if (!ClientAccess.client) return;

    var _state$ueSettings$onS = (_state$ueSettings = state.ueSettings) == null ? void 0 : _state$ueSettings.onStart,
        Encoder = _state$ueSettings$onS.Encoder,
        WebRTC = _state$ueSettings$onS.WebRTC,
        Console = _state$ueSettings$onS.Console;

    if (Encoder) {
      ClientAccess.client.sendEncoderSettings(Encoder);
    }

    if (WebRTC) {
      ClientAccess.client.sendWebRtcSettings(WebRTC);
    }

    if (Console) {
      var emitConsole = function emitConsole(payload) {
        return ClientAccess.emitConsole(payload);
      }; // // Disable keys
      // emitConsole(`PixelStreaming.KeyFilter "Escape,Esc"`)
      // Whether to hide the UE application cursor.


      if (typeof (Console == null ? void 0 : Console.cursor) === 'boolean') {
        emitConsole("PixelStreaming.HideCursor " + Console.cursor.toString());
      } // Whether to show PixelStreaming stats on the in-game HUD.


      if (typeof (Console == null ? void 0 : Console.hudSats) === 'boolean') {
        emitConsole("PixelStreaming.HudStats " + Console.hudSats.toString());
      }
    }
  }, [active]);
}; // // Disables the synchronization of audio and video tracks in WebRTC.
// PixelStreaming.WebRTC.DisableAudioSync true
// // Disables transmission of UE audio to the browser.
// // If audio is not required can improve latency in some cases.
// PixelStreaming.WebRTC.DisableTransmitAudio false
// // Disables receiving audio from the browser into UE.
// // If audio is not required can improve latency in some cases.
// PixelStreaming.WebRTC.DisableReceiveAudio false
// // [INCLUDE:#HighQpTrhesholdInfo]
// PixelStreaming.WebRTC.HighQpThreshold 37
// // Only used when PixelStreaming.Encoder.LowQP = -1. Value between 1 and 51. If WebRTC is getting frames below this QP, it will try to make an adaptation decision.
// PixelStreaming.WebRTC.LowQpThreshold 25
// // Maximum bitrate(bps) that WebRTC will not request above.
// // Be careful not to set this value too high, as a local(ideal) network will actually attempt to reach this value.
// PixelStreaming.WebRTC.MaxBitrate 20000000
// // Minimum bitrate(bps) that WebRTC will not request below.
// // Be careful not to set this value too high, otherwise WebRTC will just drop frames.
// PixelStreaming.WebRTC.MinBitrate 100000
// // Start bitrate(bps) that WebRTC will try to begin the stream with.
// // Value must be between Min and Max bitrates.
// PixelStreaming.WebRTC.StartBitrate 10000000
// // The maximum FPS WebRTC will try to capture/encode/transmit.
// PixelStreaming.WebRTC.MaxFps 60
// // [INCLUDE:#DegredationPreferenceInfo]
// PixelStreaming.WebRTC.DegradationPreference "MAINTAIN_FRAMERATE"
// // Specifies the log level of WebRTC.This is useful for debugging WebRTC.
// LogCmds=PixelStreamingWebRTC < LogLevel > Where helpful log levels are: Log, Verbose, VeryVerbose
// // Maximum number of back buffers to use. A value of 0 will not limit the number of back buffers.
// PixelStreaming.Capturer.MaxNumBackBuffers 8
// // Custom capture size to use if PixelStreaming.Capturer.UseBackBufferSize is false.
// PixelStreaming.Capturer.CaptureSize 1920x1080
// // Whether to use back buffer size or a custom size specified by PixelStreaming.Capturer.CaptureSize
// PixelStreaming.Capturer.UseBackBufferSize true

var useActions$1 = function useActions() {
  var _state$ueSettings$onS;

  var system = useSystem();

  var _useDispatch = useDispatch(),
      state = _useDispatch[0],
      dispatch = _useDispatch[1],
      eventHandler = _useDispatch[2];

  var _React$useState = React.useState(false),
      initReady = _React$useState[0],
      setInitReady = _React$useState[1];

  var refTimeoutConfig = React.useRef(null); //hack
  // pixel-streaming events

  useEventListener(EventsClass.mouseAction.key, function (payload) {
    return eventHandler.eventMouse(payload);
  });
  useEventListener(EventsClass.commands.key, function (payload) {
    return eventHandler.eventCommand(payload);
  });
  useEventListener(EventsClass.callbacks.key, function (payload) {
    return eventHandler.eventCallbacks(payload);
  });
  useEventListener(EventsClass.webrtcStatus.key, function (payload) {
    return eventHandler.eventWebrtcStatus(payload);
  });
  useEventListener(EventsClass.ueInitialSettings.key, function (payload) {
    return eventHandler.eventUeSettingsInitial(payload);
  }); // prompt before unload

  var unload = useUnload(function (e) {
    e.preventDefault();
    e.returnValue = '';
  }); // Computed data for quick access

  var computed = new ( /*#__PURE__*/function () {
    function _class() {}

    _createClass(_class, [{
      key: "streaming",
      get: function get() {
        var status = state.webrtcData.status;
        var _s_ = EventsClass.webrtcStatusList;

        var ch = function ch(v) {
          return v === status;
        };

        var res = {
          empty: status === null,
          initializing: ch(_s_.initializing),
          initialized: ch(_s_.initialized),
          active: ch(_s_.active),
          activation: ch(_s_.activation),
          disconnected: ch(_s_.disconnected),
          stopped: ch(_s_.stopped),
          error: ch(_s_.error),
          autoplaySupport: state.webrtcData.autoplaySupport,
          status: status || 'pending'
        }; // For overlays

        res._inProgress = res.empty || res.activation || res.disconnected;
        res._allowPlay = (res.initialized || res.stopped) && res.autoplaySupport !== true || res.stopped;
        res._playError = res.disconnected || res.error;
        res._allowOverlay = !res.active;
        res._isPending = res.status === 'pending';
        return res;
      }
    }, {
      key: "mouse",
      get: function get() {
        return {
          moving: state.mouseEvent.moving
        };
      }
    }]);

    return _class;
  }())();
  /**
   * Apply Unreal Engine Settings on start
   */

  useUnrealSettings(state, computed.streaming.active);
  /**
   * Resolution adapter
   */

  var resolution = useResolution((_state$ueSettings$onS = state.ueSettings.onStart) == null ? void 0 : _state$ueSettings$onS.Console);
  /**
   * Auto restart
   */

  React.useEffect(function () {
    // If client not inited yet... return
    if (!ClientAccess.client) return;

    if (computed.streaming.error && state.config.autoRestart) {
      console.error('@@@restarting...');
      cls.streamingConnect();
    }
  }, [computed.streaming.error]);
  /**
   * Percentage progress for seconds to start
   */

  var loadingContdown = useCountdown();
  React.useEffect(function () {
    if (computed.streaming.empty) {
      var sec = state.config.secondsToStart;

      if (typeof sec === 'number' && sec > 0) {
        loadingContdown.start(sec);
      }
    }

    if (computed.streaming.initialized) {
      loadingContdown.stop();
    }
  }, [computed.streaming.initialized, state.config.secondsToStart]);
  /**
   * Kill stream if secondsToKill > 0
   */

  useStreamKiller(dispatch, computed.streaming.active, state.config);
  /**
   * Streaming activation
   */

  React.useEffect(function () {
    if (computed.streaming.active) {
      // Show prompt befor exit
      unload.activate(); // Apply current resolution

      resolution.resize();
    } else {
      unload.deactivate();
    }
  }, [computed.streaming.active]);
  /**
   * Init build if ready
   */

  React.useEffect(function () {
    if (system.cls.streamingUrl) {
      cls.initPlayer(system.cls.streamingUrl);
    }
  }, [system.cls.streamingUrl]);
  /**
   * Update build config
   * $sessionData — prevent init twice
   */

  var sessionData = system.state.sessionData;
  React.useEffect(function () {
    if (sessionData) {
      var secondsToStart = system.cls.sessionData.secondsToStart;

      if (typeof secondsToStart === 'number' && secondsToStart > 0 && !state.secondsToStart) {
        dispatch.updateConfig({
          secondsToStart: secondsToStart
        });
      }
    }
  }, [sessionData]);
  /**
   * Wrapper for Client
   */

  var cls = new ( /*#__PURE__*/function () {
    function _class2() {
      this.initReady = initReady;
    } // useful info


    var _proto = _class2.prototype;

    /**
     * Allow command if RTCPlayer exist and connection is active
     */
    _proto._allowCommand = function _allowCommand(command) {
      if (!ClientAccess.client || !computed.streaming.active) {
        console.error('@@@error, streaming not active', {
          command: command
        });
        return;
      }

      return true;
    }
    /**
     * Emit system command
     */
    ;

    _proto.emitCommandSystem = function emitCommandSystem(command, value) {
      if (!this._allowCommand(command)) return;
      ClientAccess.emitCommandSystem(command, value);
    }
    /**
     * Check callbacks_list and mark command item
     * as confirmed if callback found by verification_id
     */
    ;

    _proto.emitAsyncCommand =
    /*#__PURE__*/
    function () {
      var _emitAsyncCommand = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(command, value) {
        var emitItem, ms, attempts, _loop, i, _ret;

        return _regeneratorRuntime().wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._allowCommand(command)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                emitItem = ClientAccess.emitCommand(command, value);
                ms = 100;
                attempts = 5 * (ms / 10);
                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {
                  var _iterator, _step, item;

                  return _regeneratorRuntime().wrap(function _loop$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return new Promise(function (r) {
                            return setTimeout(r, ms, i);
                          });

                        case 2:
                          _iterator = _createForOfIteratorHelperLoose(window.callbacks_list || []);

                        case 3:
                          if ((_step = _iterator()).done) {
                            _context.next = 9;
                            break;
                          }

                          item = _step.value;

                          if (!((item == null ? void 0 : item.verification_id) === (emitItem == null ? void 0 : emitItem.verification_id))) {
                            _context.next = 7;
                            break;
                          }

                          return _context.abrupt("return", {
                            v: item
                          });

                        case 7:
                          _context.next = 3;
                          break;

                        case 9:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _loop);
                });
                i = 0;

              case 7:
                if (!(i < attempts)) {
                  _context2.next = 15;
                  break;
                }

                return _context2.delegateYield(_loop(i), "t0", 9);

              case 9:
                _ret = _context2.t0;

                if (!(typeof _ret === "object")) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", _ret.v);

              case 12:
                i++;
                _context2.next = 7;
                break;

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee, this);
      }));

      function emitAsyncCommand(_x, _x2) {
        return _emitAsyncCommand.apply(this, arguments);
      }

      return emitAsyncCommand;
    }()
    /**
     * Emit command via portal commands (by uuid)
     */
    ;

    _proto.emitUuidAsync =
    /*#__PURE__*/
    function () {
      var _emitUuidAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uuid) {
        var _iterator2, _step2, item;

        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelperLoose(system.cls.commands_project);

              case 1:
                if ((_step2 = _iterator2()).done) {
                  _context3.next = 9;
                  break;
                }

                item = _step2.value;

                if (!(item.command_uuid === uuid)) {
                  _context3.next = 7;
                  break;
                }

                _context3.next = 6;
                return this.emitAsyncCommand(item.command, item.value);

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
                _context3.next = 1;
                break;

              case 9:
                return _context3.abrupt("return", false);

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this);
      }));

      function emitUuidAsync(_x3) {
        return _emitUuidAsync.apply(this, arguments);
      }

      return emitUuidAsync;
    }()
    /**
     * One time config initialization
     */
    ;

    _proto.initConfig = function initConfig(config, psConfig, ueSettings) {
      dispatch.updateConfig(config);
      dispatch.updatePsConfig(psConfig);
      dispatch.updateUeSettingsOnStart(ueSettings); // Delay for saving configs

      clearTimeout(refTimeoutConfig.current);
      refTimeoutConfig.current = setTimeout(function () {
        setInitReady(true);
      }, 300);
    } // Handle player initialization
    ;

    _proto.initPlayer = function initPlayer(streamingUrl) {
      if (!streamingUrl) {
        console.error('Missing data:', {
          streamingUrl: streamingUrl
        });
        return;
      } // Send status handler for webrtc state changing


      dispatch.updateConfig({
        streamingUrl: streamingUrl
      });
      dispatch.updateWebrtcData({
        status: 'initializing'
      }); // Init client once

      new ClientClass(streamingUrl, state.psConfig).init();
    };

    _proto.streamingConnect = function streamingConnect() {
      ClientAccess.connect();
    };

    _proto.streamingStop = function streamingStop() {
      ClientAccess.close();
    };

    _proto.switchStart = function switchStart() {
      computed.streaming.active ? this.streamingStop() : this.streamingConnect();
    };

    _proto.clientCb = function clientCb(cb) {
      var client = ClientAccess.client;
      if (client) cb(client);
    };

    _proto.changeVolume = function changeVolume(volume) {
      if (volume === void 0) {
        volume = 1;
      }

      this.clientCb(function (cl) {
        if (!cl.videoPlayerController.audioElement) {
          cl.videoPlayerController.PlayAudioTrack();
          volume = 1;
        } else {
          if (volume > 0) {
            cl.videoPlayerController.audioElement.play();
          } else if (volume === 0) {
            cl.videoPlayerController.audioElement.pause();
          }

          cl.videoPlayerController.audioElement.volume = volume;
        }
      }); // this.emitCommandSystem('user_sound', { volume })

      dispatch.updatePlayerSettings({
        volume: volume
      });
    };

    _createClass(_class2, [{
      key: "info",
      get: function get() {
        return {
          loading: loadingContdown
        };
      } // useful methods

    }, {
      key: "methods",
      get: function get() {
        return {
          commands: {
            clear: function clear() {
              return dispatch.update({
                commands_list: []
              });
            }
          },
          callbacks: {
            clear: function clear() {
              return dispatch.update({
                callbacks_list: []
              });
            }
          }
        };
      }
    }]);

    return _class2;
  }())();
  return {
    state: state,
    cls: cls,
    computed: computed,
    dispatch: dispatch
  };
};

var AppContext$1 = /*#__PURE__*/React.createContext({});
var usePlayer = function usePlayer() {
  return React.useContext(AppContext$1);
}; // classes

var Provider$1 = function Provider(props) {
  var actions = useActions$1();
  return React.createElement(AppContext$1.Provider, {
    value: actions
  }, props.children);
};

var ContextProvider = function ContextProvider(props) {
  return React.createElement(CustomProvider, {
    theme: 'dark'
  }, React.createElement(Provider, null, React.createElement(Provider$1, null, props.children)));
};

var blue = {
  50: '#e3f2fd',
  100: '#bbdefb',
  200: '#90caf9',
  300: '#64b5f6',
  400: '#42a5f5',
  500: '#2196f3',
  600: '#1e88e5',
  700: '#1976d2',
  800: '#1565c0',
  900: '#0d47a1',
  A100: '#82b1ff',
  A200: '#448aff',
  A400: '#2979ff',
  A700: '#2962ff'
};

var lightGreen = {
  50: '#f1f8e9',
  100: '#dcedc8',
  200: '#c5e1a5',
  300: '#aed581',
  400: '#9ccc65',
  500: '#8bc34a',
  600: '#7cb342',
  700: '#689f38',
  800: '#558b2f',
  900: '#33691e',
  A100: '#ccff90',
  A200: '#b2ff59',
  A400: '#76ff03',
  A700: '#64dd17'
};

var colors = {
  primary: blue,
  success: lightGreen
};
var media = /*#__PURE__*/new ( /*#__PURE__*/function () {
  function _class() {
    this.getMax = function (_int) {
      return "@media (max-width: " + _int + "px)";
    };

    this.getMin = function (_int2) {
      return "@media (min-width: " + _int2 + "px)";
    };

    this.sizes = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    };
  } // {xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536}


  _createClass(_class, [{
    key: "down",
    get: function get() {
      return {
        xs: this.getMax(this.sizes.sm),
        sm: this.getMax(this.sizes.md),
        md: this.getMax(this.sizes.lg),
        lg: this.getMax(this.sizes.xl)
      };
    }
  }, {
    key: "up",
    get: function get() {
      return {
        xs: this.getMin(this.sizes.xs),
        sm: this.getMin(this.sizes.sm),
        md: this.getMin(this.sizes.md),
        lg: this.getMin(this.sizes.lg),
        xl: this.getMin(this.sizes.xl)
      };
    }
  }]);

  return _class;
}())();

var DebugPanel = function DebugPanel(props) {
  var _player$state$devBar;

  var player = usePlayer();
  var isFirst = props.isFirst;
  var show = isFirst ? false : true;

  if (isFirst && ((_player$state$devBar = player.state.devBar) == null ? void 0 : _player$state$devBar.slug) === 'pixelStreaming') {
    return React.createElement("div", null);
  }

  return React.createElement("div", {
    id: "playerUI",
    onWheel: function onWheel(e) {
      return e.stopPropagation();
    },
    style: {
      display: show === true ? 'block' : 'none'
    }
  }, React.createElement("div", {
    id: "overlay",
    className: "overlay"
  }, React.createElement("div", {
    id: "overlayHeader"
  }, React.createElement("div", {
    id: "qualityStatus",
    className: "greyStatus"
  }, "***"), React.createElement("div", {
    id: "overlayButton"
  }, "+")), React.createElement("div", {
    id: "overlaySettings",
    className: "container d-none"
  }, React.createElement("div", {
    id: "Controls",
    className: "row"
  }, React.createElement("section", {
    id: "preStreamOptions",
    className: "settingsContainer"
  }, React.createElement("div", {
    id: "preStreamOptionsHeader",
    className: "settings-text"
  }, React.createElement("div", null, "Pre Stream Options")), React.createElement("div", {
    className: "row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("label", {
    className: "form-check-label",
    htmlFor: "force-turn-tgl"
  }, "Force TURN")), React.createElement("div", {
    className: "form-check form-switch col-auto"
  }, React.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    role: "switch",
    id: "force-turn-tgl"
  }))), React.createElement("div", {
    className: "row",
    style: {
      paddingTop: 5,
      paddingBottom: 5
    }
  }, React.createElement("div", {
    className: "col col-auto"
  }, React.createElement("input", {
    id: "restart-stream-button",
    className: "overlay-button btn-flat",
    type: "button",
    defaultValue: "Restart Stream"
  })))), React.createElement("section", {
    id: "viewSettings",
    className: "settingsContainer"
  }, React.createElement("div", {
    id: "viewSettingsHeader",
    className: "settings-text"
  }, React.createElement("div", null, "Viewing")), React.createElement("div", {
    id: "viewSettingsContainer",
    className: "d-none"
  }, React.createElement("div", {
    className: "row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("label", {
    className: "form-check-label",
    htmlFor: "enlarge-display-to-fill-window-tgl"
  }, "Enlarge display to fill window")), React.createElement("div", {
    className: "form-check form-switch col-auto"
  }, React.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    role: "switch",
    id: "enlarge-display-to-fill-window-tgl",
    defaultChecked: true
  }))), React.createElement("div", {
    className: "row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("label", {
    className: "form-check-label",
    htmlFor: "quality-control-ownership-tgl"
  }, "Is Quality Controller")), React.createElement("div", {
    className: "form-check form-switch col-auto"
  }, React.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    role: "switch",
    id: "quality-control-ownership-tgl"
  }))), React.createElement("div", {
    className: "row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("label", {
    className: "form-check-label",
    htmlFor: "match-viewport-res-tgl"
  }, "Match viewport resolution")), React.createElement("div", {
    className: "form-check form-switch col-auto"
  }, React.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    role: "switch",
    id: "match-viewport-res-tgl"
  }))), React.createElement("div", {
    className: "row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("label", {
    className: "form-check-label",
    htmlFor: "control-scheme-tgl",
    id: "control-scheme-title"
  }, "Match viewport resolution")), React.createElement("div", {
    className: "form-check form-switch col-auto"
  }, React.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    role: "switch",
    id: "control-scheme-tgl"
  }))))), React.createElement("section", {
    id: "commands",
    className: "settingsContainer"
  }, React.createElement("div", {
    id: "commandsHeader",
    className: "settings-text"
  }, React.createElement("div", null, "Commands")), React.createElement("div", {
    id: "commandsContainer",
    className: "d-none"
  }, React.createElement("div", {
    className: "row",
    style: {
      paddingTop: 5,
      paddingBottom: 5
    }
  }, React.createElement("div", {
    className: "row",
    style: {
      paddingTop: 5,
      paddingBottom: 5
    }
  }, React.createElement("div", {
    className: "col col-auto"
  }, React.createElement("input", {
    id: "show-fps-button",
    className: "overlay-button btn-flat",
    type: "button",
    defaultValue: "Show FPS"
  }))), React.createElement("div", {
    className: "col col-auto"
  }, React.createElement("label", {
    htmlFor: "ui-descriptor-text",
    className: "settings-text"
  }, "UI Descriptor")), React.createElement("div", {
    className: "col col-auto"
  }, React.createElement("input", {
    type: "text",
    className: "form-control form-control-sm",
    id: "ui-descriptor-text"
  })), React.createElement("div", {
    className: "col col-auto"
  }, React.createElement("input", {
    type: "button",
    id: "sendUiDescriptor",
    className: "overlay-button btn-flat",
    defaultValue: "Send"
  }))))), React.createElement("section", {
    id: "streamingSettings",
    className: "settingsContainer"
  }, React.createElement("div", {
    id: "streamingSettingsHeader",
    className: "settings-text"
  }, React.createElement("div", null, "Settings")), React.createElement("div", {
    id: "streamingSettingsContainer",
    className: "d-none"
  }, React.createElement("div", {
    className: "form-group row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("div", null, "Encoder Settings"), React.createElement("div", {
    id: "encoderSettings",
    className: "col"
  }, React.createElement("div", {
    className: "form-group row"
  }, React.createElement("label", {
    htmlFor: "encoder-min-qp-text"
  }, "Min QP"), React.createElement("input", {
    type: "number",
    className: "form-control form-control-sm",
    id: "encoder-min-qp-text",
    defaultValue: "0",
    min: "0",
    max: "51"
  })), React.createElement("div", {
    className: "form-group row"
  }, React.createElement("label", {
    htmlFor: "encoder-max-qp-text"
  }, "Max QP"), React.createElement("input", {
    type: "number",
    className: "form-control form-control-sm",
    id: "encoder-max-qp-text",
    defaultValue: "51",
    min: "0",
    max: "51"
  })))), React.createElement("div", {
    className: "col-sm"
  }, React.createElement("div", null, "WebRTC Settings"), React.createElement("div", {
    id: "webrtcSettings"
  }, React.createElement("div", {
    className: "form-group row"
  }, React.createElement("label", {
    htmlFor: "webrtc-fps-text"
  }, "FPS"), React.createElement("input", {
    type: "number",
    className: "form-control form-control-sm",
    id: "webrtc-fps-text",
    defaultValue: "0",
    min: "1",
    max: "999"
  })), React.createElement("div", {
    className: "form-group row"
  }, React.createElement("label", {
    htmlFor: "webrtc-min-bitrate-text"
  }, "Min bitrate (bps)"), React.createElement("input", {
    type: "number",
    className: "form-control form-control-sm",
    id: "webrtc-min-bitrate-text",
    defaultValue: "0",
    min: "0",
    max: "100000"
  })), React.createElement("div", {
    className: "form-group row"
  }, React.createElement("label", {
    htmlFor: "webrtc-max-bitrate-text"
  }, "Max bitrate (bps)"), React.createElement("input", {
    type: "number",
    className: "form-control form-control-sm",
    id: "webrtc-max-bitrate-text",
    defaultValue: "0",
    min: "0",
    max: "100000"
  }))))), React.createElement("div", {
    className: "form-group row"
  }, React.createElement("input", {
    id: "btn-streaming-settings",
    className: "overlay-button btn-flat",
    type: "button",
    defaultValue: "Apply"
  })))), React.createElement("section", {
    id: "statistics",
    className: "settingsContainer"
  }, React.createElement("div", {
    id: "statisticsHeader",
    className: "settings-text"
  }, React.createElement("div", null, "Statistics")), React.createElement("div", {
    id: "statisticsContainer",
    className: "d-none"
  }, React.createElement("div", {
    className: "row"
  }, React.createElement("div", {
    className: "col-sm"
  }, React.createElement("label", {
    className: "form-check-label",
    htmlFor: "send-stats-tgl",
    id: "control-scheme-title"
  }, "Send to server")), React.createElement("div", {
    className: "form-check form-switch col-auto"
  }, React.createElement("input", {
    className: "form-check-input",
    type: "checkbox",
    role: "switch",
    id: "send-stats-tgl"
  }))), React.createElement("div", {
    id: "statisticsResult",
    className: "StatsResult"
  }))), React.createElement("section", {
    id: "latencyTest",
    className: "settingsContainer"
  }, React.createElement("div", {
    id: "latencyTestHeader",
    className: "settings-text"
  }, React.createElement("div", null, "Latency Test"), React.createElement("input", {
    id: "btn-start-latency-test",
    className: "overlay-button btn-flat",
    type: "button",
    defaultValue: "Run Test"
  })), React.createElement("div", {
    id: "latencyTestContainer",
    className: "d-none"
  }, React.createElement("div", {
    id: "latencyStatsResults",
    className: "StatsResult"
  })))))));
};

var _header;
var useStyles = /*#__PURE__*/reactJss.createUseStyles({
  header: (_header = {}, _header[media.down.xs] = {
    marginTop: 40
  }, _header),
  container: {
    overflow: 'auto',
    pointerEvents: 'all',
    maxHeight: 'calc(100vh - 77px)'
  }
});
var CustomDrawer = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var classes = useStyles();

  var _React$useState = React.useState(false),
      open = _React$useState[0],
      setOpen = _React$useState[1];

  var _React$useState2 = React.useState({
    body: props.withBody,
    title: props.title,
    Component: null
  }),
      config = _React$useState2[0],
      setConfig = _React$useState2[1];
  /**
   * The component instance will be extended
   * with whatever you return from the callback passed
   * as the second argument
   */


  React.useImperativeHandle(ref, function () {
    return {
      open: function open(title, body, Component) {
        if (Component === void 0) {
          Component = null;
        }

        setConfig(function (c) {
          return _extends({}, c, {
            title: title || c.title,
            body: body || c.body,
            Component: Component || null
          });
        });
        setOpen(true);
      },
      close: function close() {
        handleClose();
      },
      isOpen: open
    };
  });

  var handleClose = function handleClose() {
    setOpen(false);

    if (typeof props.onClose === 'function') {
      props.onClose();
    }
  };

  var renderChildren = function renderChildren() {
    var Children = config.Component || props.children;

    if (config.body) {
      return React.createElement("div", {
        style: {
          padding: 20
        }
      }, Children);
    }

    return Children;
  };

  return React.createElement(Drawer, {
    size: 'xs',
    placement: 'right',
    backdrop: false,
    open: open,
    onClose: handleClose
  }, React.createElement(Drawer.Header, {
    className: classes.header
  }, typeof config.title === 'string' ? React.createElement(Drawer.Title, null, config.title) : config.title, props.ActionsComponent ? React.createElement(Drawer.Actions, {
    style: {
      marginRight: -20
    }
  }, props.ActionsComponent) : ''), React.createElement("div", {
    onWheel: function onWheel(e) {
      e.stopPropagation();
    },
    className: classes.container
  }, renderChildren()));
});

var JsonViewer = function JsonViewer(props) {
  return React.createElement(ReactJson, {
    style: {
      backgroundColor: 'transparent'
    },
    theme: 'monokai',
    quotesOnKeys: false,
    groupArraysAfterLength: 2,
    collapseStringsAfterLength: 10,
    displayDataTypes: false,
    displayObjectSize: false,
    enableClipboard: false,
    src: props.data
  });
};

var Panel = function Panel() {
  var player = usePlayer();

  var renderState = function renderState() {
    var res = player.state;
    delete res.callbacks_list;
    delete res.commands_list; // delete res.sessionData

    return res;
  };

  return React.createElement("div", null, React.createElement(JsonViewer, {
    data: renderState()
  }));
};

var Panel$1 = function Panel() {
  var system = useSystem();
  return React.createElement("div", null, React.createElement(JsonViewer, {
    data: system.state
  }));
};

var useStyles$1 = /*#__PURE__*/reactJss.createUseStyles({
  groupList: {
    listStyle: 'none',
    margin: 0,
    padding: 0,
    marginBottom: 10,
    paddingBottom: 10,
    borderBottom: "solid 1px rgba(255,255,255,.1)",
    '& > li': {
      '&:nth-child(1)': {
        opacity: .7,
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        maxWidth: 200,
        marginBottom: 10
      },
      '&:nth-child(2)': {
        display: 'flex',
        flexWrap: 'wrap',
        gap: 5
      }
    }
  }
});
var CommandsList = function CommandsList(props) {
  var classes = useStyles$1();
  var player = usePlayer();
  var system = useSystem();

  var _React$useState = React.useState({}),
      performers = _React$useState[0],
      setPerformers = _React$useState[1];

  React.useEffect(function () {
    system.cls.loadData();
  }, []);

  var handlePerformer = function handlePerformer(id, status) {
    setPerformers(function (c) {
      var _extends2;

      return _extends({}, c, (_extends2 = {}, _extends2[id] = status, _extends2));
    });
  };

  var handlerCommand = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(item) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              handlePerformer(item.id, 'loading');
              _context.next = 3;
              return player.cls.emitAsyncCommand(item.slug, item.value).then(function (res) {
                if (res) {
                  handlePerformer(item.id, 'success');
                } else {
                  handlePerformer(item.id, 'error');
                }
              });

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handlerCommand(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var renderCommandsList = function renderCommandsList() {
    var groups = {};
    props.list.map(function (item) {
      if (typeof groups[item.slug] === 'undefined') {
        var _item$group;

        groups[item.slug] = {
          name: item.slug,
          group: (_item$group = item.group) == null ? void 0 : _item$group.name,
          items: []
        };
      }

      groups[item.slug].items.push(item);
    });
    var group_list = Object.values(groups);
    return React.createElement("div", null, group_list.map(function (group, index) {
      return React.createElement("ul", {
        key: index,
        className: classes.groupList
      }, React.createElement("li", null, group.name, " (", group.group, ")"), React.createElement("li", null, group.items.map(function (item, i) {
        var status = false;

        if (performers.hasOwnProperty(item.id)) {
          status = performers[item.id];
        }

        var isLoading = status === 'loading'; // const isError = status === 'error'
        // const isSuccess = status === 'success'

        var getName = function getName() {
          if (typeof (item == null ? void 0 : item.name) === 'undefined') return '';

          if (item.name.length > 20) {
            return item.name.substr(0, 17) + '...';
          }

          return item.name;
        };

        return React.createElement("div", {
          key: index + "-" + i
        }, React.createElement(IconButton, {
          onClick: function onClick() {
            return handlerCommand(item);
          },
          loading: isLoading,
          icon: React.createElement(CopyIcon, {
            style: {
              zIndex: 10
            },
            onClick: function onClick(event) {
              event.preventDefault();
              event.stopPropagation();
              navigator.clipboard.writeText(item.command_uuid).then(function () {
                alert("Uuid copied:\n" + item.command_uuid);
              }, function (err) {
                console.error('Async: Could not copy text: ', err);
              });
            }
          }),
          placement: "left"
        }, getName()));
      })));
    }));
  };

  return React.createElement("div", null, renderCommandsList());
};

var Panel$2 = function Panel() {
  var system = useSystem();
  return React.createElement("div", null, React.createElement(CommandsList, {
    list: system.cls.commands_project
  }));
};

var Panel$3 = function Panel() {
  var player = usePlayer();
  var system = useSystem();
  return React.createElement("div", null, React.createElement(Button, {
    block: true,
    style: {
      marginBottom: 20
    },
    onClick: function onClick() {
      return player.cls.switchStart();
    }
  }, "Start / stop"), React.createElement(CommandsList, {
    list: system.cls.commands_system
  }));
};

var Panel$4 = function Panel() {
  var _player$state;

  var player = usePlayer();
  return React.createElement("div", null, React.createElement(Button, {
    style: {
      marginBottom: 10
    },
    block: true,
    onClick: function onClick() {
      return player.cls.methods.commands.clear();
    }
  }, "Clear"), React.createElement(JsonViewer, {
    data: (_player$state = player.state) == null ? void 0 : _player$state.commands_list
  }));
};

var Panel$5 = function Panel() {
  var _player$state;

  var player = usePlayer();
  return React.createElement("div", null, React.createElement(Button, {
    style: {
      marginBottom: 10
    },
    block: true,
    onClick: function onClick() {
      return player.cls.methods.callbacks.clear();
    }
  }, "Clear"), React.createElement(JsonViewer, {
    data: (_player$state = player.state) == null ? void 0 : _player$state.callbacks_list
  }));
};

var NotificationsSettings = function NotificationsSettings() {
  var system = useSystem();

  var _React$useState = React.useState({
    type: 'info',
    header: 'Some title'
  }),
      data = _React$useState[0],
      setData = _React$useState[1];

  var message = React.createElement(Notification, {
    type: data.type,
    header: data.header,
    closable: true
  });
  return React.createElement("div", null, message, React.createElement(ButtonToolbar, null, React.createElement(SelectPicker, {
    value: data.type,
    data: [{
      label: 'Test command',
      value: 'info'
    }, {
      label: 'Test callback',
      value: 'success'
    }],
    onChange: function onChange(type, event) {
      setData({
        type: type,
        header: event.target.innerText
      });
    }
  }), React.createElement(SelectPicker, {
    defaultValue: system.notifications.placementValue,
    data: system.notifications.placementsList,
    onChange: function onChange(v) {
      system.notifications.updatePlacement(v);
    }
  }), React.createElement(Button, {
    onClick: function onClick() {
      return toaster.push(message, {
        placement: system.notifications.placementValue
      });
    }
  }, "Push")), React.createElement(ButtonToolbar, null, React.createElement(Button, {
    onClick: function onClick() {
      return toaster.remove('');
    }
  }, "Remove"), React.createElement(Button, {
    onClick: function onClick() {
      return toaster.clear();
    }
  }, "Clear")));
};

var Panel$6 = function Panel() {
  var system = useSystem();
  return React.createElement("div", null, React.createElement(Form.Group, null, React.createElement(Form.ControlLabel, null, "System Notifications"), React.createElement("div", {
    style: {
      display: 'flex',
      gap: 5,
      paddingTop: 10
    }
  }, React.createElement(Toggle, {
    checked: system.notifications.showCommands,
    onChange: function onChange(v) {
      return system.notifications.updateCommands(v);
    },
    size: "lg",
    checkedChildren: "Commands: on",
    unCheckedChildren: "Commands: off"
  }), React.createElement(Toggle, {
    checked: system.notifications.showCallbacks,
    onChange: function onChange(v) {
      return system.notifications.updateCallbacks(v);
    },
    size: "lg",
    checkedChildren: "Callbacks: on",
    unCheckedChildren: "Callbacks: off"
  }))), React.createElement("div", {
    style: {
      paddingTop: 20
    }
  }, React.createElement(NotificationsSettings, null)));
};

var Panel$7 = function Panel() {
  return React.createElement("div", null, React.createElement(DebugPanel, null));
};

var DevMenu = function DevMenu(props) {
  var refDrawer = React.useRef(null);
  var system = useSystem();
  var menuList = [['Player Data', 'playerData', React.createElement(ListIcon, null), React.createElement(Panel, null)], ['Meta Data', 'metaData', React.createElement(ListIcon, null), React.createElement(Panel$1, null)], ['Menu: system', 'menuSystem', React.createElement(ProjectIcon, null), React.createElement(Panel$3, null)], ['Menu: project', 'menuProject', React.createElement(ProjectIcon, null), React.createElement(Panel$2, null)], ['History: commands', 'historyCommands', React.createElement(HistoryIcon, null), React.createElement(Panel$4, null)], ['History: callbacks', 'historyCallbacks', React.createElement(HistoryIcon, null), React.createElement(Panel$5, null)], ['Settings', 'settings', React.createElement(SettingIcon, null), React.createElement(Panel$6, null)], ['Pixel Streaming', 'pixelStreaming', React.createElement(PlayOutlineIcon, null), React.createElement(Panel$7, null)]].map(function (_ref) {
    var label = _ref[0],
        slug = _ref[1],
        Icon = _ref[2],
        Component = _ref[3];
    return {
      label: label,
      slug: slug,
      Icon: Icon,
      Component: Component
    };
  });

  var openPanel = function openPanel(item) {
    system.dispatch.updateDevBar({
      slug: item.slug
    });
    refDrawer.current.open(item.label, true, item.Component);
  };

  return React.createElement("div", null, React.createElement(CustomDrawer, {
    onClose: function onClose() {
      return props.onClose();
    },
    ref: refDrawer
  }), React.createElement(Sidenav, {
    defaultOpenKeys: ['3', '4']
  }, React.createElement(Sidenav.Body, null, React.createElement(Nav, null, menuList.map(function (item, index) {
    return React.createElement(Nav.Item, {
      key: index,
      icon: React.createElement(React.Fragment, null, item.Icon),
      eventKey: index.toString(),
      children: item.label,
      onClick: function onClick() {
        openPanel(item);
      }
    });
  })))), React.createElement(React.Fragment, null));
};

var CustomModal = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _React$useState = React.useState(false),
      open = _React$useState[0],
      setOpen = _React$useState[1];
  /**
   * The component instance will be extended
   * with whatever you return from the callback passed
   * as the second argument
   */


  React.useImperativeHandle(ref, function () {
    return {
      open: function open() {
        setOpen(true);
      },
      close: function close() {
        handleClose();
      },
      isOpen: open
    };
  });

  var handleClose = function handleClose() {
    setOpen(false);

    if (typeof props.onClose === 'function') {
      props.onClose();
    }
  };

  var handleSuccess = function handleSuccess() {
    if (typeof props.onSuccess === 'function') {
      props.onSuccess();
    }

    handleClose();
  };

  var showFooter = props.FooterComponent !== false;
  return React.createElement(Modal, {
    open: open,
    onClose: handleClose
  }, React.createElement(Modal.Header, null, React.createElement(Modal.Title, null, props.title)), React.createElement(Modal.Body, null, props.children), showFooter && React.createElement(Modal.Footer, null, props.FooterComponent || React.createElement(React.Fragment, null, React.createElement(Button, {
    onClick: handleSuccess,
    appearance: "primary"
  }, "Ok"), React.createElement(Button, {
    onClick: handleClose,
    appearance: "subtle"
  }, "Cancel"))));
});

var Actions = function Actions() {
  var _system$cls, _system$cls$apiData;

  var system = useSystem();
  var storageBook = useStorageBook();
  var refModal = React.useRef(null);

  var _React$useState = React.useState(''),
      value = _React$useState[0],
      setValue = _React$useState[1];

  var _React$useState2 = React.useState(false),
      setError = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      disabled = _React$useState3[0],
      setDisabled = _React$useState3[1];

  var error = (_system$cls = system.cls) == null ? void 0 : (_system$cls$apiData = _system$cls.apiData) == null ? void 0 : _system$cls$apiData.error;
  React.useEffect(function () {
    storageBook.apiKey.read(function (v) {
      if (v) setValue(v);
    });
  }, []);

  var handleOpen = function handleOpen() {
    refModal.current.open();
  };

  var handleSubmit = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
      var isDataLoaded;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (event) {
                event.stopPropagation();
                event.preventDefault();
              }

              setDisabled(true);
              setError(false);
              _context.next = 5;
              return system.cls.loadData(value);

            case 5:
              isDataLoaded = _context.sent;

              if (isDataLoaded) {
                system.cls.setApiKey(value);
                refModal.current.close();
              } else {
                setError('Wrong Api Key');
              }

              setDisabled(false);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handleSubmit(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  return React.createElement("div", null, React.createElement(CustomModal, {
    title: "Api Connector",
    onSuccess: undefined,
    onClose: undefined,
    FooterComponent: React.createElement(React.Fragment, null, React.createElement(Button, {
      onClick: function onClick() {
        window.open(config.portal.urlProjects);
      }
    }, "My Projects"), React.createElement(Button, {
      disabled: disabled,
      onClick: handleSubmit,
      appearance: "primary"
    }, "Connect")),
    ref: refModal
  }, React.createElement("div", null, React.createElement(Message, {
    showIcon: true,
    type: "warning",
    style: {
      marginBottom: 20
    }
  }, "Copy your Api Key from ", React.createElement("a", {
    href: config.portal.urlProjects,
    target: "_blank"
  }, config.portal.name)), React.createElement("form", {
    onSubmit: handleSubmit
  }, React.createElement(Input, {
    disabled: disabled,
    value: value,
    onChange: setValue,
    size: 'lg',
    required: true,
    placeholder: "Enter Api Key"
  }), error && React.createElement("div", {
    style: {
      color: 'red',
      marginTop: 10
    }
  }, error)))), system.cls.apiKeyIsCorrect ? React.createElement(Button, {
    color: 'green',
    appearance: 'ghost',
    onClick: handleOpen
  }, "Reconnect Project") : React.createElement(Button, {
    color: 'red',
    appearance: 'primary',
    onClick: handleOpen
  }, "Connect Project"));
};

var UpdateMessage = function UpdateMessage() {
  var system = useSystem();
  var data = system.cls.apiData.module;

  if (!(data != null && data.update)) {
    return React.createElement("div", null);
  }

  return React.createElement("div", {
    style: {
      padding: '1rem'
    }
  }, React.createElement(Button, {
    color: "red",
    appearance: "primary",
    block: true,
    href: config.updateUrl,
    target: "_blank"
  }, "Update MetaEditor to v", data == null ? void 0 : data.release));
};

var useStyles$2 = /*#__PURE__*/reactJss.createUseStyles({
  titleList: {
    margin: 0,
    display: 'flex',
    alignItems: 'center',
    '& > li:nth-child(2) > span': {
      marginLeft: 10,
      padding: '3px 5px',
      borderRadius: 4,
      fontSize: 11,
      backgroundColor: 'rgba(255,255,255,.3)'
    }
  }
});
var DevBar = function DevBar() {
  var classes = useStyles$2();
  var system = useSystem();
  var refDrawer = React.useRef(null);

  var setDrawerSlug = function setDrawerSlug() {
    system.dispatch.updateDevBar({
      slug: 'drawer'
    });
  };

  var openDrawer = function openDrawer() {
    setDrawerSlug();

    if (refDrawer.current.isOpen) {
      refDrawer.current.close();
    } else {
      refDrawer.current.open();
    }
  };

  reactHotkeysHook.useHotkeys('ctrl+z', function (e) {
    if (!e.repeat) {
      openDrawer();
      return;
    }
  }, []);
  return React.createElement("div", null, React.createElement(IconButton, {
    onClick: function onClick() {
      return openDrawer();
    },
    icon: React.createElement(GearIcon, null),
    circle: true,
    size: "lg"
  }), React.createElement(CustomDrawer, {
    onClose: function onClose() {
      system.dispatch.updateDevBar({
        slug: null
      });
    },
    ref: refDrawer,
    withBody: false,
    title: React.createElement("ul", {
      className: classes.titleList
    }, React.createElement("li", null, React.createElement("h6", null, "MetaEditor")), React.createElement("li", null, React.createElement("span", null, "v", config.version))),
    ActionsComponent: React.createElement(Actions, null)
  }, React.createElement("div", null, React.createElement(UpdateMessage, null), React.createElement(DevMenu, {
    onClose: function onClose() {
      setDrawerSlug();
    }
  }))));
};

var useStyles$3 = /*#__PURE__*/reactJss.createUseStyles({
  root: {
    transition: 'opacity 700ms linear',
    backgroundColor: '#000',
    position: 'fixed',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 1050 - 100,
    '& > video': {
      width: '100%',
      height: '100%',
      objectFit: 'cover',
      opacity: .4,
      position: 'absolute',
      overflow: 'hidden',
      alignItems: 'center',
      justifyContent: 'center',
      pointerEvents: 'none',
      zIndex: -1
    }
  },
  box: {
    fontSize: 12,
    opacity: .7,
    display: 'inline-block',
    cursor: 'default'
  },
  reportLink: {
    display: 'inline-block',
    marginTop: 10,
    borderBottom: "solid 1px rgba(255,255,255,.3)",
    cursor: 'pointer'
  }
});
var PlayerOverlay = function PlayerOverlay() {
  var classes = useStyles$3();
  var player = usePlayer();
  var system = useSystem();
  var refRoot = React.useRef(null);
  var _player$cls$info$load = player.cls.info.loading,
      percent = _player$cls$info$load.percent,
      time = _player$cls$info$load.time;
  var videoUrl = system.config.videoUrl;
  var _player$computed$stre = player.computed.streaming,
      status = _player$computed$stre.status,
      _isPending = _player$computed$stre._isPending,
      _inProgress = _player$computed$stre._inProgress,
      _allowPlay = _player$computed$stre._allowPlay,
      _allowOverlay = _player$computed$stre._allowOverlay,
      _playError = _player$computed$stre._playError;
  React.useEffect(function () {
    refRoot.current.style.opacity = _allowOverlay ? 1 : 0;
    refRoot.current.style.pointerEvents = _allowOverlay ? 'all' : 'none';
  }, [_allowOverlay]);

  var renderButton = function renderButton(_onClick, Icon, spin) {
    return React.createElement(IconButton, {
      onClick: function onClick(event) {
        event.preventDefault();
        event.stopPropagation();

        _onClick();
      },
      circle: true,
      icon: React.createElement(Icon, {
        spin: spin,
        style: {
          fontSize: '5em'
        }
      })
    });
  };

  var renderContent = function renderContent() {
    // const { active, empty, activation, initialized, initializing } = player.computed.streaming
    var eProps = {
      style: {
        width: 120,
        cursor: 'default'
      },
      percent: percent,
      showInfo: true
    };

    if (_playError) {
      return React.createElement(Progress.Circle, Object.assign({}, eProps, {
        status: 'fail'
      }));
    } else if (_inProgress && percent > 0) {
      //  else if (_allowPlay || initialized || active || percent >= 100) {
      //   return (<Progress.Circle {...eProps} status='success' />)
      // }
      return React.createElement(Progress.Circle, Object.assign({}, eProps, {
        status: 'active'
      }));
    } else if (_allowPlay) {
      return renderButton(function () {
        return player.cls.streamingConnect();
      }, PlayOutlineIcon, false);
    }

    return renderButton(function () {}, GearIcon, true);
  };

  var renderStatus = function renderStatus() {
    return React.createElement("div", {
      style: {
        textAlign: 'center'
      }
    }, React.createElement("div", {
      style: {
        margin: 20
      }
    }, renderContent()), React.createElement("div", {
      className: classes.box
    }, React.createElement("div", {
      style: {
        textTransform: 'uppercase',
        letterSpacing: 2
      }
    }, status, " ", _isPending && percent > 0 ? time : ''), system.config.issuesUrl ? React.createElement("div", {
      onClick: function onClick() {
        return window.open(system.config.issuesUrl);
      },
      className: classes.reportLink
    }, "Report a problem") : ''));
  };

  return React.createElement("div", {
    ref: refRoot,
    className: classes.root
  }, videoUrl ? React.createElement("video", {
    loop: true,
    autoPlay: true,
    muted: true
  }, React.createElement("source", {
    src: videoUrl,
    type: "video/mp4"
  })) : '', renderStatus());
};

var useStyles$4 = /*#__PURE__*/reactJss.createUseStyles({
  root: {
    width: function width(_ref) {
      var size = _ref.size;
      return size;
    },
    height: function height(_ref2) {
      var size = _ref2.size;
      return size;
    },
    fontSize: function fontSize(_ref3) {
      var size = _ref3.size;
      return size / 1.3;
    },
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    overflow: 'hidden'
  }
});
var defaultProps = {
  name: 'volumeOn',
  size: 20
};
var SvgIcon = function SvgIcon(props) {
  if (props === void 0) {
    props = defaultProps;
  }

  var _props = props,
      size = _props.size,
      name = _props.name;
  var classes = useStyles$4({
    size: size
  });
  var list = {
    volumeOn: freeSolidSvgIcons.faVolumeHigh,
    volumeOff: freeSolidSvgIcons.faVolumeOff,
    expand: freeSolidSvgIcons.faExpand,
    qrcode: freeSolidSvgIcons.faQrcode,
    compress: freeSolidSvgIcons.faCompress,
    play: freeSolidSvgIcons.faPlay,
    pause: freeSolidSvgIcons.faPause,
    star: freeSolidSvgIcons.faStar,
    arrowLeft: freeSolidSvgIcons.faSquareCaretLeft,
    arrowRight: freeSolidSvgIcons.faSquareCaretRight,
    arrowUp: freeSolidSvgIcons.faSquareCaretUp,
    arrowDown: freeSolidSvgIcons.faSquareCaretDown,
    question: freeSolidSvgIcons.faQuestion
  };

  var renderIcon = function renderIcon() {
    var getIcon = function getIcon() {
      if (!list.hasOwnProperty(name)) {
        return React.createElement(React.Fragment, null);
      }

      return list[name];
    };

    return React.createElement("span", {
      className: classes.root
    }, React.createElement(reactFontawesome.FontAwesomeIcon, {
      icon: getIcon()
    }));
  };

  if (props.button) {
    return React.createElement(IconButton, {
      disabled: props.disabled,
      onClick: function onClick() {
        if (typeof props.onClick === 'function') {
          props.onClick();
        }
      },
      icon: renderIcon(),
      circle: true,
      size: props.buttonSize
    });
  }

  return renderIcon();
};
SvgIcon.defaultProps = defaultProps;

var useFullscreen = function useFullscreen() {
  var _React$useState = React.useState(false),
      active = _React$useState[0],
      setActive = _React$useState[1]; // Hot key


  reactHotkeysHook.useHotkeys('ctrl+f', function (e) {
    if (!e.repeat) {
      cls.open();
      return;
    }
  }, []);

  var fullscreenchanged = function fullscreenchanged() {
    if (document.fullscreenElement) {
      console.log("Element: " + document.fullscreenElement.id + " entered fullscreen mode.");
      setActive(true);
    } else {
      console.log('Leaving fullscreen mode.');
      setActive(false);
    }
  };

  React.useEffect(function () {
    document.addEventListener('fullscreenchange', fullscreenchanged);
    return function () {
      document.removeEventListener('fullscreenchange', fullscreenchanged);
    };
  }, []);
  var cls = new ( /*#__PURE__*/function () {
    function _class() {
      // Get the documentElement (<html>) to display the page in fullscreen
      this.doc = document.documentElement;
      this.active = active;
    }
    /* View in fullscreen */


    var _proto = _class.prototype;

    _proto.open = function open() {
      if (this.doc.requestFullscreen) {
        this.doc.requestFullscreen().then(function () {// element has entered fullscreen mode successfully
        })["catch"](function (error) {
          console.error({
            error: error
          });
        });
      } else if (this.doc.webkitRequestFullscreen) {
        /* Safari */
        this.doc.webkitRequestFullscreen().then(function () {// element has entered fullscreen mode successfully
        })["catch"](function (error) {
          console.error({
            error: error
          });
        });
      } else if (this.doc.msRequestFullscreen) {
        /* IE11 */
        this.doc.msRequestFullscreen().then(function () {// element has entered fullscreen mode successfully
        })["catch"](function (error) {
          console.error({
            error: error
          });
        });
      }
    }
    /* Close fullscreen */
    ;

    _proto.close = function close() {
      if (document.fullscreenElement) {
        document.exitFullscreen().then(function () {
          return console.log("Document Exited from Full screen mode");
        })["catch"](function (err) {
          return console.error(err);
        });
      } else {
        document.documentElement.requestFullscreen();
      } // if (document.exitFullscreen) {
      //   document.exitFullscreen();
      // } else if (document.webkitExitFullscreen) { /* Safari */
      //   document.webkitExitFullscreen();
      // } else if (document.msExitFullscreen) { /* IE11 */
      //   document.msExitFullscreen();
      // }

    };

    return _class;
  }())();
  return cls;
};

var useCopy = function useCopy() {
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.text = function text(_text) {
      navigator.clipboard.writeText(_text).then(function () {
        console.log('Async: Copying to clipboard was successful!');
        alert('Copied!');
      }, function (err) {
        console.error('Async: Could not copy text: ', err);
      });
    };

    return _class;
  }())();
  return cls;
};

/* Usage

// components
import QrCode from 'src/components/QrCode/'

function Demo() {

  return (

  )
}
*/
var defaultProps$1 = {
  level: 'L',
  fgColor: '#000000',
  // fgColor: 'var(--rs-bg-overlay)',
  bgColor: '#FFFFFF',
  value: '',
  size: 26,
  title: ''
};
var QrCode = function QrCode(props) {
  if (props === void 0) {
    props = defaultProps$1;
  }

  return React.createElement("div", null, React.createElement(ReactQRCode, {
    level: props.level,
    bgColor: props.bgColor,
    fgColor: props.fgColor,
    size: props.size,
    title: props.title,
    value: props.value
  }));
};

var useStyles$5 = /*#__PURE__*/reactJss.createUseStyles({
  root: {
    backgroundColor: '#fff',
    padding: '60px 30px',
    display: 'flex',
    justifyContent: 'center',
    borderRadius: 10,
    marginTop: 30
  }
});
var ShareLink = function ShareLink() {
  var classes = useStyles$5();
  var system = useSystem();
  var player = usePlayer();
  var copy = useCopy();
  var refModal = React.useRef(null);
  var sharedUrl = system.cls.sharedUrl;
  return React.createElement("div", null, React.createElement(CustomModal, {
    title: "Quick Access",
    onSuccess: undefined,
    onClose: undefined,
    FooterComponent: undefined,
    ref: refModal
  }, React.createElement("div", null, React.createElement("div", {
    style: {
      marginBottom: 10
    }
  }, "Copy the address or scan the QR code with your phone."), React.createElement(InputGroup, {
    size: 'lg'
  }, React.createElement(Input, {
    readOnly: true,
    defaultValue: sharedUrl || ''
  }), React.createElement(InputGroup.Button, {
    onClick: function onClick() {
      return copy.text(sharedUrl);
    }
  }, React.createElement(CopyIcon, null))), React.createElement("div", {
    className: classes.root
  }, React.createElement(QrCode, {
    value: sharedUrl
  })))), React.createElement(SvgIcon, {
    disabled: !sharedUrl,
    button: true,
    buttonSize: 'lg',
    name: 'qrcode',
    onClick: function onClick() {
      player.cls.streamingStop();
      refModal.current.open();
    }
  }));
};

var useStyles$6 = /*#__PURE__*/reactJss.createUseStyles({
  popover: {
    width: 150,
    padding: 10
  }
});
var VolumeButton = function VolumeButton() {
  var classes = useStyles$6();
  var player = usePlayer();
  var refWhisper = React.useRef(null);
  var active = player.computed.streaming.active;
  var soundButtonDisabled = !active;
  var volume = player.state.playerSettings.volume;
  var volumeOff = typeof volume === 'number' && volume <= 0;

  var renderSpeacker = function renderSpeacker() {
    var _player$state$playerS;

    return React.createElement(Popover, {
      title: "Volume"
    }, React.createElement("div", {
      className: classes.popover
    }, React.createElement(Slider, {
      getAriaValueText: function getAriaValueText(_int) {
        return _int * 100 + "%";
      },
      tooltip: false,
      min: 0,
      max: 1,
      step: .1,
      value: (_player$state$playerS = player.state.playerSettings) == null ? void 0 : _player$state$playerS.volume,
      onChange: function onChange(v) {
        return player.cls.changeVolume(v);
      }
    })));
  };

  return React.createElement("div", null, React.createElement(Whisper, {
    ref: refWhisper,
    placement: "left",
    trigger: "hover",
    enterable: true,
    disabled: soundButtonDisabled,
    speaker: renderSpeacker()
  }, React.createElement("div", null, React.createElement(SvgIcon, {
    button: true,
    buttonSize: 'lg',
    name: volumeOff ? 'volumeOff' : 'volumeOn',
    disabled: soundButtonDisabled,
    onClick: function onClick() {
      var v = volume === 0 ? 1 : 0;
      player.cls.changeVolume(v);
    }
  }))));
};

var useNotify = function useNotify() {
  var message = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto.clear = function clear() {
      // toaster.remove('')
      toaster.clear();
    };

    _proto.push = function push(children, options, settings) {
      var message = React.createElement(Message, Object.assign({}, options), children);
      toaster.push(message, settings);
    };

    return _class;
  }())();
  return {
    message: message
  };
};

var useStyles$7 = /*#__PURE__*/reactJss.createUseStyles({
  content: {},
  keysList: {
    marginBottom: 20,
    width: 230,
    fontSize: '.8rem',
    '& > li': {
      display: 'flex',
      alignItems: 'center',
      padding: '3px 0',
      '& label': {
        width: 100
      },
      '& > div': {
        display: 'flex',
        alignItems: 'center',
        '& > span': {
          margin: '0 4px'
        }
      }
    }
  },
  button: {
    backgroundColor: '#fff',
    color: 'rgba(0,0,0,.7)'
  }
});
var KeyboardHelper = function KeyboardHelper() {
  var classes = useStyles$7();
  var notify = useNotify();
  var player = usePlayer();
  React.useEffect(function () {
    if (player.computed.streaming.active) {
      setTimeout(function () {
        handleOpen();
      }, 1000 * 3);
    }
  }, [player.computed.streaming.active]);

  var renderContent = function renderContent() {
    var list = [['Move up', 'W', 'arrowUp'], ['Move down', 'S', 'arrowDown'], ['Move left', 'A', 'arrowLeft'], ['Move left', 'D', 'arrowRight']].map(function (_ref) {
      var label = _ref[0],
          key = _ref[1],
          icon = _ref[2];
      return {
        label: label,
        key: key,
        icon: icon
      };
    });
    return React.createElement("div", {
      className: classes.content
    }, React.createElement("ul", {
      className: classes.keysList
    }, list.map(function (item, index) {
      return React.createElement("li", {
        key: index
      }, React.createElement("label", null, item.label), React.createElement("div", null, "Press \"", item.key, "\" or ", React.createElement(SvgIcon, {
        name: item.icon,
        size: 20
      })));
    })), React.createElement(Button, {
      onClick: function onClick() {
        return notify.message.clear();
      },
      appearance: 'primary',
      className: classes.button
    }, "I got it"));
  };

  var handleOpen = function handleOpen() {
    // notify.message.clear()
    notify.message.push(renderContent(), {
      header: 'HotKeys',
      showIcon: false,
      type: 'info',
      closable: true,
      duration: 1000 * 10
    }, {
      placement: 'bottomEnd'
    });
  };

  return React.createElement(SvgIcon, {
    button: true,
    buttonSize: 'lg',
    name: 'question',
    onClick: function onClick() {
      handleOpen();
    }
  }); // return (
  //   <div
  //     onClick={() => handleOpen()}
  //     style={{
  //       top: 30,
  //       left: 30,
  //       position: 'fixed', zIndex: 1000,
  //       // backgroundColor: 'red'
  //     }}>
  //     {renderContent()}
  //   </div>
  // )
};

var Helpers = {
  KeyboardHelper: KeyboardHelper
};

var PlayerActions = function PlayerActions() {
  var player = usePlayer();
  var fullscreen = useFullscreen();
  var _player$computed$stre = player.computed.streaming,
      _allowPlay = _player$computed$stre._allowPlay,
      active = _player$computed$stre.active;
  var playButtonDisabled = !_allowPlay && !active;
  return React.createElement(React.Fragment, null, React.createElement(SvgIcon, {
    button: true,
    buttonSize: 'lg',
    name: active ? 'pause' : 'play',
    disabled: playButtonDisabled,
    onClick: function onClick() {
      player.cls.switchStart();
    }
  }), React.createElement(VolumeButton, null), React.createElement(SvgIcon, {
    button: true,
    buttonSize: 'lg',
    name: fullscreen.active ? 'compress' : 'expand',
    onClick: function onClick() {
      if (fullscreen.active) {
        fullscreen.close();
      } else {
        fullscreen.open();
      }
    }
  }), React.createElement(ShareLink, null), React.createElement(Helpers.KeyboardHelper, null));
};

var useMedia = function useMedia() {
  var defaultSizes = {
    xs: false,
    sm: false,
    md: false,
    lg: false,
    xl: false
  };

  var _React$useState = React.useState(defaultSizes),
      size = _React$useState[0],
      setSize = _React$useState[1];

  var change = function change(key) {
    var _setSize;

    setSize((_setSize = {
      defaultSizes: defaultSizes
    }, _setSize[key] = true, _setSize));
  }; // Handler to call on window resize


  var handleResize = function handleResize() {
    var width = window.innerWidth;

    if (width > media.sizes.xl) {
      // > 1536
      change('xl');
    } else if (width > media.sizes.lg) {
      // > 1200
      change('lg');
    } else if (width > media.sizes.md) {
      // > 900
      change('md');
    } else if (width > media.sizes.sm) {
      // > 600
      change('sm');
    } else {
      change('xs');
    } // console.log('@@@size', size)

  }; // useEventListener('resize', handleResize)


  React.useEffect(function () {
    window.addEventListener("resize", function () {
      return handleResize();
    });
    handleResize();
    return function () {
      return window.removeEventListener("resize", function () {
        return handleResize();
      });
    };
  }, []);
  return size;
};

function useBridge() {
  var system = useSystem();
  var player = usePlayer();
  var cls = new ( /*#__PURE__*/function () {
    function _class() {}

    var _proto = _class.prototype;

    _proto._emit = /*#__PURE__*/function () {
      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uuid) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return player.cls.emitUuidAsync(uuid);

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function _emit(_x) {
        return _emit2.apply(this, arguments);
      }

      return _emit;
    }();

    _createClass(_class, [{
      key: "menu",
      get: function get() {
        var _this = this;

        var click = function click(uuid) {
          if (uuid) {
            _this._emit(uuid);
          }
        };

        var list = system.project.menu || [];
        return list.map(function (item) {
          return _extends({}, item, {
            onClick: function onClick() {
              return click(item.command_uuid);
            },
            subitems: item.subitems.map(function (sub) {
              return _extends({}, sub, {
                onClick: function () {
                  var _onClick = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            click(item.command_uuid);
                            _context2.next = 3;
                            return click(sub.command_uuid);

                          case 3:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  function onClick() {
                    return _onClick.apply(this, arguments);
                  }

                  return onClick;
                }()
              });
            })
          });
        });
      }
    }]);

    return _class;
  }())();
  return cls;
}

var _excluded = ["onClose", "items"];

var _div, _root;
var useStyles$8 = /*#__PURE__*/reactJss.createUseStyles({
  root: (_root = {
    position: 'fixed',
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 1050 - 10,
    display: 'flex',
    justifyContent: 'center'
  }, _root[media.up.sm] = {
    left: 10,
    right: 10,
    bottom: 10
  }, _root['& > div'] = (_div = {
    opacity: function opacity(_ref) {
      var isMoving = _ref.isMoving;
      return isMoving ? .3 : 1;
    },
    backgroundColor: 'rgba(0,0,0,.8)'
  }, _div[media.down.sm] = {
    width: '100%',
    borderTop: "solid 1px rgba(255,255,255,.1)"
  }, _div[media.up.sm] = {
    backdropFilter: 'blur(5px)',
    border: "solid 1px rgba(255,255,255,.1)",
    borderRadius: 5,
    transition: 'opacity .5s ease-in-out',
    padding: '0 10px'
  }, _div), _root),
  dropdownItem: {
    display: 'flex',
    alignItems: 'center',
    minWidth: 150,
    maxWidth: 200,
    '& > img': {
      width: 50,
      borderRadius: 5,
      marginRight: 10
    }
  },
  mobileNavbar: {
    display: 'flex',
    alignItems: 'center',
    margin: 0,
    padding: '0 10px',
    // minHeight: 56,
    '& > [data-li="logo"]': {
      fontWeight: 600,
      minWidth: 100,
      whiteSpace: 'nowrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      padding: '15px 10px'
    },
    '& > [data-li="menu"]': {
      flex: 1,
      overflowY: 'auto'
    }
  },
  mobileMenu: {
    display: 'flex',
    '& > li': {
      padding: '15px 10px',
      '& label': {
        fontSize: '.8rem',
        textTransform: 'uppercase'
      }
    }
  }
}); // interface MobilePopoverProps {
// }

var MenuPopover = /*#__PURE__*/React.forwardRef(function (_ref2, ref) {
  var onClose = _ref2.onClose,
      items = _ref2.items,
      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);

  var classes = useStyles$8({
    isMoving: false
  });
  return React.createElement(Popover, Object.assign({
    ref: ref
  }, rest, {
    full: true
  }), React.createElement(Dropdown.Menu, null, items.map(function (item, index) {
    return React.createElement(Dropdown.Item, {
      key: index,
      onClick: function onClick() {
        item.onClick();
        onClose();
      }
    }, React.createElement("div", {
      className: classes.dropdownItem
    }, item.preview_small ? React.createElement("img", {
      src: item.preview_small
    }) : '', item.name));
  })));
});
var Panel$8 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var system = useSystem();
  var player = usePlayer();
  var bridge = useBridge();

  var _media = useMedia();

  var refMobilePopover = React.useRef();

  var _React$useState = React.useState(null),
      activeKey = _React$useState[0],
      setActiveKey = _React$useState[1];

  var isDisabled = !player.computed.streaming.active;
  var isMoving = player.computed.mouse.moving;
  var classes = useStyles$8({
    isMoving: isMoving
  });
  var isMobile = _media.xs || _media.sm;

  var renderMobileMenu = function renderMobileMenu() {
    var closeMobileMenu = function closeMobileMenu() {
      refMobilePopover.current.close();
    };

    return React.createElement("div", null, React.createElement("ul", {
      className: classes.mobileNavbar
    }, React.createElement("li", {
      "data-li": "logo"
    }, system.project.name), React.createElement("li", {
      "data-li": "menu"
    }, React.createElement("ul", {
      className: classes.mobileMenu
    }, bridge.menu.map(function (item, index) {
      if (item.subitems.length > 0) {
        return React.createElement("li", {
          key: index
        }, React.createElement(Whisper, {
          controlId: "mobile-menu-popover",
          placement: index < bridge.menu.length - 3 ? "top" : "topEnd",
          trigger: "click",
          ref: refMobilePopover,
          speaker: React.createElement(MenuPopover, {
            items: item.subitems,
            onClose: closeMobileMenu
          })
        }, React.createElement("label", null, item.name)));
      }

      return React.createElement("li", {
        key: index,
        onClick: function onClick(event) {
          event.preventDefault();
          item.onClick();
          closeMobileMenu();
        }
      }, React.createElement("label", null, item.name));
    })))));
  };

  var renderContent = function renderContent() {
    return React.createElement(Navbar, {
      appearance: 'subtle'
    }, React.createElement(Navbar.Brand, {
      style: {
        cursor: 'default'
      }
    }, React.createElement("strong", null, system.project.name)), React.createElement(Nav, {
      onSelect: setActiveKey,
      activeKey: activeKey,
      style: {
        whiteSpace: 'unset'
      }
    }, bridge.menu.map(function (item, index) {
      if (item.subitems.length > 0) {
        return React.createElement(Dropdown, {
          key: index,
          eventKey: index,
          placement: "topStart",
          title: item.name
        }, item.subitems.map(function (subitem, i) {
          var key = index + "-" + i;
          return React.createElement(Dropdown.Item, {
            key: key,
            eventKey: key,
            disabled: isDisabled,
            onClick: function onClick() {
              return subitem.onClick();
            }
          }, React.createElement("div", {
            className: classes.dropdownItem
          }, subitem.preview_small ? React.createElement("img", {
            src: subitem.preview_small
          }) : '', subitem.name));
        }));
      }

      return React.createElement(Nav.Item, {
        key: index,
        eventKey: index.toString(),
        disabled: isDisabled,
        onClick: function onClick(event) {
          event.preventDefault();
          item.onClick();
        }
      }, item.name);
    })));
  };

  return React.createElement("div", {
    className: classes.root
  }, React.createElement("div", null, React.createElement("div", Object.assign({}, props, {
    ref: ref
  }), isMobile ? renderMobileMenu() : renderContent())));
});
var QuickMenu = function QuickMenu() {
  var system = useSystem();

  if (!system.project.exist) {
    return React.createElement("div", null);
  }

  return React.createElement(Animation.Slide, {
    "in": true,
    placement: 'bottom'
  }, function (props, ref) {
    return React.createElement(Panel$8, Object.assign({}, props, {
      ref: ref
    }));
  });
};

var useStyles$9 = /*#__PURE__*/reactJss.createUseStyles({
  progressRoot: {
    position: 'absolute',
    zIndex: 1050 - 10,
    top: 27,
    left: 'calc((100vw - 200px) / 2)',
    right: 0,
    width: 200,
    pointerEvents: 'none'
  },
  progress: {
    display: 'flex',
    alignItems: 'center',
    textShadow: '1px 1px rgba(0,0,0, .2)',
    '& .rs-progress-line-outer': {
      border: 'solid 1px rgba(0,0,0, .1)',
      '& .rs-progress-line-inner': {
        backgroundColor: 'rgba(255,255,255, .3)'
      }
    }
  }
});
var ProgressKiller = function ProgressKiller() {
  var classes = useStyles$9();
  var player = usePlayer();
  var contdown = useCountdown();

  var _React$useState = React.useState(false),
      mounted = _React$useState[0],
      setMounted = _React$useState[1];

  var secondsToKill = player.state.config.secondsToKill || 0;
  var secondsToKillLeft = player.state.config.secondsToKillLeft || 0;
  var active = player.computed.streaming.active;
  React.useEffect(function () {
    if (active) {
      if (!mounted && secondsToKill > 0) {
        setMounted(true);
      }

      if (mounted && secondsToKillLeft > 0) {
        contdown.start(secondsToKillLeft);
      }
    } else {
      contdown.stop();
    }
  }, [active, secondsToKillLeft]);
  var show = contdown.active && active;

  if (!mounted) {
    return React.createElement("div", null);
  }

  return React.createElement(Animation.Slide, {
    "in": show,
    placement: 'top'
  }, function (props, ref) {
    return React.createElement("div", {
      className: classes.progressRoot
    }, React.createElement("div", Object.assign({}, props, {
      ref: ref
    }), React.createElement("div", {
      className: classes.progress
    }, React.createElement(Progress.Line, {
      showInfo: false,
      strokeColor: '#fff',
      percent: contdown.percent,
      status: 'active'
    }), React.createElement("div", {
      style: {
        width: 60
      }
    }, contdown.time))));
  });
};

var _rsSidenavDefault;

var global = {
  '@global': {
    body: {
      overscrollBehavior: 'contain'
    },
    // rsuit
    '.rs-drawer-wrapper': {
      pointerEvents: 'none',
      '& *': {
        pointerEvents: 'all'
      }
    },
    '.rs-drawer': {
      backdropFilter: 'blur(5px)',
      borderLeft: 'solid 1px rgba(255, 255, 255, .2)'
    },
    '.rs-drawer-content': {
      backgroundColor: 'rgba(0, 0, 0, .8)'
    },
    '.rs-sidenav-default': (_rsSidenavDefault = {
      backgroundColor: 'transparent',
      '& .rs-dropdown-toggle, & .rs-sidenav-item': {
        backgroundColor: 'transparent'
      }
    }, _rsSidenavDefault["& .rs-dropdown.rs-dropdown-open .rs-dropdown-toggle,\n        & .rs-dropdown .rs-dropdown-toggle,\n        & .rs-sidenav-item,\n        & .rs-dropdown-toggle,\n        & .rs-sidenav-item"] = {
      backgroundColor: 'transparent',
      '&:hover': {
        backgroundColor: 'rgba(255, 255, 255, .3)'
      }
    }, _rsSidenavDefault),
    '.rs-toast.rs-notification': {
      width: 320
    },
    '.rs-notification': {
      width: '100%'
    }
  }
};

var useStyles$a = /*#__PURE__*/reactJss.createUseStyles( /*#__PURE__*/_extends({}, global, {
  root: {
    margin: 0,
    backgroundColor: 'black',
    height: 'var(--window - height)',
    overflow: 'hidden',
    '& #player': {
      '& video': {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 50,
        zIndex: 0,
        objectFit: "var(--player-object-fit)",
        cursor: 'pointer'
      }
    }
  },
  toolbar: {
    position: 'fixed',
    zIndex: 1050 - 1,
    top: 20,
    right: 20,
    display: 'flex',
    flexDirection: 'column',
    gap: 10
  }
}));
var Player = function Player(props) {
  var classes = useStyles$a();
  var player = usePlayer();
  var system = useSystem();
  var apiKey = props.apiKey,
      metaConfig = props.metaConfig,
      config = props.config,
      psConfig = props.psConfig,
      ueSettings = props.ueSettings;

  var _React$useState = React.useState(false),
      inited = _React$useState[0],
      setInited = _React$useState[1];

  React.useEffect(function () {
    system.cls.setApiKey(apiKey);
    system.cls.initMetaConfig(metaConfig);
    player.cls.initConfig(config, psConfig, ueSettings);
  }, []);
  /**
   * Enrich config from system context
   */

  React.useEffect(function () {
    if (inited === false && system.project.config) {
      var _system$project$confi = system.project.config,
          menu = _system$project$confi.menu,
          ue_console_mode = _system$project$confi.ue_console_mode,
          ue_control_scheme = _system$project$confi.ue_control_scheme,
          ue_sound = _system$project$confi.ue_sound;
      system.cls.initMetaConfig({
        showQuickMenu: menu
      });
      ueSettings.Console.mode = ue_console_mode;
      psConfig.controlScheme = ue_control_scheme;
      psConfig.startVideoMuted = !ue_sound;
      setInited(true);
      player.cls.initConfig(config, psConfig, ueSettings);
    }
  }, [system.project.config]);
  return React.createElement("div", {
    className: classes.root
  }, React.createElement("div", {
    id: "player"
  }), React.createElement(DebugPanel, {
    isFirst: true
  }), system.config.showOverlay && React.createElement(PlayerOverlay, null), system.config.showQuickMenu && React.createElement(QuickMenu, null), React.createElement(ProgressKiller, null), (system.config.showToolbar || system.config.showDevBar) && React.createElement("div", {
    className: classes.toolbar,
    id: "metaeditor-toolbar"
  }, system.config.showDevBar && React.createElement(DevBar, null), system.config.showToolbar && React.createElement(PlayerActions, null)));
};

Object.defineProperty(exports, 'jss', {
  enumerable: true,
  get: function () {
    return reactJss.createUseStyles;
  }
});
exports.ContextProvider = ContextProvider;
exports.CustomDrawer = CustomDrawer;
exports.CustomModal = CustomModal;
exports.Player = Player;
exports.Request = Request;
exports.SvgIcon = SvgIcon;
exports.colors = colors;
exports.config = config;
exports.media = media;
exports.useMedia = useMedia;
exports.usePlayer = usePlayer;
exports.useStorage = useStorage;
exports.useSystem = useSystem;
//# sourceMappingURL=pixel-streaming.cjs.development.js.map
