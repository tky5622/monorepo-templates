"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneNpmLockFile = exports.stringifyNpmLockFile = exports.parseNpmLockFile = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
/**
 * Parses package-lock.json file to `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function parseNpmLockFile(lockFile) {
    const _a = JSON.parse(lockFile), { packages, dependencies } = _a, metadata = tslib_1.__rest(_a, ["packages", "dependencies"]);
    return {
        dependencies: mapPackages(packages),
        lockFileMetadata: {
            metadata,
            rootPackage: packages[''],
        },
    };
}
exports.parseNpmLockFile = parseNpmLockFile;
// Maps /node_modules/@abc/def with version 1.2.3 => @abc/def > @abc/dev@1.2.3
function mapPackages(packages) {
    const mappedPackages = {};
    Object.entries(packages).forEach((_a) => {
        var [key, _b] = _a, { dev, optional } = _b, value = tslib_1.__rest(_b, ["dev", "optional"]);
        // skip root package
        if (!key) {
            return;
        }
        // key can have several instances of 'node_modules' if hoisted package
        const packageName = key.slice(key.lastIndexOf('node_modules/') + 13);
        mappedPackages[packageName] = mappedPackages[packageName] || {};
        const packageMeta = {
            path: key,
            dev,
            optional,
        };
        const newKey = packageName + '@' + value.version;
        if (mappedPackages[packageName][newKey]) {
            mappedPackages[packageName][newKey].packageMeta.push(packageMeta);
        }
        else {
            mappedPackages[packageName][newKey] = Object.assign(Object.assign({}, value), { packageMeta: [packageMeta] });
        }
    });
    return mappedPackages;
}
/**
 * Generates package-lock.json file from `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function stringifyNpmLockFile(lockFileData) {
    const dependencies = {};
    const packages = {
        '': lockFileData.lockFileMetadata.rootPackage,
    };
    const keys = Object.keys(lockFileData.dependencies);
    for (let i = 0; i < keys.length; i++) {
        const packageName = keys[i];
        const packageVersions = lockFileData.dependencies[packageName];
        const values = Object.values(packageVersions);
        values.forEach((value) => {
            unmapPackage(packages, value);
            unmapPackageDependencies(dependencies, packageName, value);
        });
    }
    // generate package lock JSON
    const lockFileJson = Object.assign(Object.assign({}, lockFileData.lockFileMetadata.metadata), { packages: (0, utils_1.sortObject)(packages), dependencies: sortDependencies(dependencies) });
    return JSON.stringify(lockFileJson, null, 2) + '\n';
}
exports.stringifyNpmLockFile = stringifyNpmLockFile;
// remapping the package back to package-lock format
function unmapPackage(packages, _a) {
    var { packageMeta } = _a, value = tslib_1.__rest(_a, ["packageMeta"]);
    // we need to decompose value, to achieve particular field ordering
    const { version, resolved, integrity, license, devOptional, hasInstallScript } = value, rest = tslib_1.__rest(value, ["version", "resolved", "integrity", "license", "devOptional", "hasInstallScript"]);
    for (let i = 0; i < packageMeta.length; i++) {
        const { path, dev, optional } = packageMeta[i];
        // we are sorting the properties to get as close as possible to the original package-lock.json
        packages[path] = Object.assign({ version,
            resolved,
            integrity,
            dev,
            devOptional,
            hasInstallScript,
            license,
            optional }, rest);
    }
}
function unmapPackageDependencies(dependencies, packageName, _a) {
    var { packageMeta } = _a, value = tslib_1.__rest(_a, ["packageMeta"]);
    const { version, resolved, integrity, devOptional } = value;
    for (let i = 0; i < packageMeta.length; i++) {
        const { path, dev, optional } = packageMeta[i];
        const projectPath = path.split('node_modules/').slice(1);
        const innerDeps = getProjectNodeAndEnsureParentHierarchy(projectPath, dependencies);
        const requires = unmapDependencyRequires(value);
        // sorting fields to match package-lock structure
        innerDeps[packageName] = Object.assign({ version,
            resolved,
            integrity,
            dev,
            devOptional,
            optional,
            requires }, innerDeps[packageName]);
    }
}
// generates/ensures entire parent hierarchy exists for the given project path
// returns pointer to last project in the path
function getProjectNodeAndEnsureParentHierarchy(projects, dependencies) {
    while (projects.length > 1) {
        const parentName = projects.shift().replace(/\/$/, '');
        if (!dependencies[parentName]) {
            dependencies[parentName] = {};
        }
        if (!dependencies[parentName].dependencies) {
            dependencies[parentName].dependencies = {};
        }
        dependencies = dependencies[parentName].dependencies;
    }
    return dependencies;
}
// combine dependencies and optionalDependencies into requires and sort them
function unmapDependencyRequires(value) {
    if (!value.dependencies && !value.optionalDependencies) {
        return undefined;
    }
    const dependencies = Object.assign(Object.assign({}, (value.dependencies || {})), (value.optionalDependencies || {}));
    const sortedKeys = Object.keys(dependencies).sort();
    const result = {};
    for (let i = 0; i < sortedKeys.length; i++) {
        const key = sortedKeys[i];
        result[key] = dependencies[key];
    }
    return result;
}
// recursively sort dependencies
function sortDependencies(unsortedDependencies) {
    const dependencies = {};
    const sortedKeys = Object.keys(unsortedDependencies).sort();
    for (let i = 0; i < sortedKeys.length; i++) {
        const value = unsortedDependencies[sortedKeys[i]];
        dependencies[sortedKeys[i]] = value;
        if (value.dependencies) {
            value.dependencies = sortDependencies(value.dependencies);
        }
    }
    return dependencies;
}
/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
function pruneNpmLockFile(lockFileData, packages) {
    // todo(meeroslav): This functionality has not been implemented yet
    console.warn('Pruning package-lock.json is not yet implemented. Returning entire lock file');
    return lockFileData;
}
exports.pruneNpmLockFile = pruneNpmLockFile;
//# sourceMappingURL=npm.js.map