"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const environment_1 = require("./utilities/environment");
const axios_1 = require("./utilities/axios");
const cloud_enabled_runner_1 = require("./core/runners/cloud-enabled/cloud-enabled.runner");
const distributed_task_execution_detection_1 = require("./utilities/distributed-task-execution-detection");
const { tasksRunner, output, runnerReturnsPromise, } = require('./utilities/nx-imports');
const nxCloudTasksRunner = (tasks, options, context) => {
    const nxArgs = context.nxArgs;
    const noAccessTokenDefined = !environment_1.ACCESS_TOKEN && !options.accessToken;
    const noCloud = nxArgs['cloud'] === false;
    if (noAccessTokenDefined || noCloud) {
        return tasksRunner(tasks, options, context);
    }
    if (environment_1.NX_INVOKED_BY_RUNNER) {
        if (anyCacheableTargets(tasks, options)) {
            return (0, cloud_enabled_runner_1.cloudEnabledTasksRunner)(tasks, options, context, true);
        }
        else {
            return tasksRunner(tasks, options, context);
        }
    }
    if (environment_1.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION) {
        verifyAllOperationsAreCacheableOnAgent(tasks, options);
    }
    // distributed execution, main job
    if ((0, distributed_task_execution_detection_1.isDistributedExecutionEnabled)(nxArgs['dte']) &&
        !environment_1.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION) {
        verifyAllOperationsAreCacheableOnMainJob(tasks, options);
        if (runnerReturnsPromise) {
            return dtePromiseVersion(tasks, options, context);
        }
        else {
            return dteLegacyObservableVersion(tasks, options, context);
        }
    }
    // This disables using Cloud for all inner nx invocations, so it won't create an extra run.
    process.env.NX_INVOKED_BY_RUNNER = 'true';
    return (0, cloud_enabled_runner_1.cloudEnabledTasksRunner)(tasks, options, context);
};
function dteLegacyObservableVersion(tasks, options, context) {
    const { from } = require('rxjs/internal/observable/from');
    const { switchMap } = require('rxjs/internal/operators/switchMap');
    return from(verifyNxCloudWorkspaceEnabled(options)).pipe(switchMap((res) => {
        if (res.data.enabled) {
            return require('./core/runners/distributed-execution/distributed-execution.runner').nxCloudDistributedTasksRunner(tasks, options, context);
        }
        output.warn({
            title: 'Nx Cloud: Workspace Disabled',
            bodyLines: [
                'This run and following runs will not use distributed task execution until',
                'the outstanding balance is paid or additional coupons are added for this',
                'workspace. If you believe you are receiving this message in error, please',
                'contact support at cloud-support@nrwl.io.',
                '',
                'Execution will now continue using this machine only.',
            ],
        });
        // This disables using Cloud for all inner nx invocations, so it won't create an extra run.
        process.env.NX_INVOKED_BY_RUNNER = 'true';
        return (0, cloud_enabled_runner_1.cloudEnabledTasksRunner)(tasks, options, context);
    }));
}
function dtePromiseVersion(tasks, options, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const isEnabled = yield verifyNxCloudWorkspaceEnabled(options);
        if (isEnabled.data.enabled) {
            return require('./core/runners/distributed-execution/distributed-execution.runner').nxCloudDistributedTasksRunner(tasks, options, context);
        }
        else {
            output.warn({
                title: 'Nx Cloud: Workspace Disabled',
                bodyLines: [
                    'This run and following runs will not use distributed task execution until',
                    'the outstanding balance is paid or additional coupons are added for this',
                    'workspace. If you believe you are receiving this message in error, please',
                    'contact support at cloud-support@nrwl.io.',
                    '',
                    'Execution will now continue using this machine only.',
                ],
            });
            // This disables using Cloud for all inner nx invocations, so it won't create an extra run.
            process.env.NX_INVOKED_BY_RUNNER = 'true';
            return (0, cloud_enabled_runner_1.cloudEnabledTasksRunner)(tasks, options, context);
        }
    });
}
function verifyNxCloudWorkspaceEnabled(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const axiosInstance = (0, axios_1.createApiAxiosInstance)(options);
        return yield (0, axios_1.axiosMultipleTries)(() => axiosInstance.get('/nx-cloud/executions/workspace-status'));
    });
}
function anyCacheableTargets(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    for (const task of tasks) {
        if (cacheableTargets.indexOf(task.target.target) > -1) {
            return true;
        }
    }
    return false;
}
function verifyAllOperationsAreCacheableOnMainJob(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    for (const task of tasks) {
        if (cacheableTargets.indexOf(task.target.target) === -1) {
            output.error({
                title: `Distributed task execution only works for cacheable targets`,
                bodyLines: [
                    `Target '${task.target.project}:${task.target.target}' cannot be executed.`,
                    `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
                    `You can verify that '${task.target.target}' is part of the list of cacheable targets in the 'nx.json' file.`,
                    `You can invoke this command without distribution by doing "NX_CLOUD_DISTRIBUTED_EXECUTION=false nx ...".`,
                ],
            });
            process.exit(1);
        }
    }
}
function verifyAllOperationsAreCacheableOnAgent(tasks, options) {
    const cacheableTargets = options.cacheableOperations || [];
    tasks.forEach((task) => {
        if (cacheableTargets.indexOf(task.target.target) === -1) {
            output.error({
                title: `Distributed task execution only works for cacheable targets`,
                bodyLines: [
                    `Target ${task.target.project}:${task.target.target} cannot be executed.`,
                    `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
                    `You can still invoke "nx ${task.target.target} ${task.target.project}" from within a cacheable target when using "nx:run-commands".`,
                ],
            });
            process.exit(environment_1.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
        }
    });
}
exports.default = nxCloudTasksRunner;
//# sourceMappingURL=nx-cloud-tasks-runner.js.map