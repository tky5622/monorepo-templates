"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_server_1 = require("@storybook/core-server");
require("dotenv/config");
const utils_1 = require("../utils");
function storybookExecutor(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* storybookExecutor_1() {
        let frameworkPath = (0, utils_1.getStorybookFrameworkPath)(options.uiFramework);
        const frameworkOptions = (yield tslib_1.__await(Promise.resolve().then(() => require(frameworkPath)))).default;
        const option = storybookOptionMapper(options, frameworkOptions, context);
        // print warnings
        (0, utils_1.runStorybookSetupCheck)(options);
        yield tslib_1.__await(runInstance(option));
        yield yield tslib_1.__await({ success: true });
        // This Promise intentionally never resolves, leaving the process running
        yield tslib_1.__await(new Promise(() => { }));
    });
}
exports.default = storybookExecutor;
function runInstance(options) {
    var _a;
    const env = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : 'development';
    process.env.NODE_ENV = env;
    return (0, core_server_1.buildDev)(Object.assign(Object.assign({}, options), { configType: env.toUpperCase() }));
}
function storybookOptionMapper(builderOptions, frameworkOptions, context) {
    const storybookOptions = Object.assign(Object.assign(Object.assign({}, builderOptions), (0, utils_1.resolveCommonStorybookOptionMapper)(builderOptions, frameworkOptions, context)), { mode: 'dev', watch: true });
    return storybookOptions;
}
//# sourceMappingURL=storybook.impl.js.map