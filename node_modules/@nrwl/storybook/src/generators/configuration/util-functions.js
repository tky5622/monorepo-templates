"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addBuildStorybookToCacheableOperations = exports.getTsConfigPath = exports.createProjectStorybookDir = exports.createRootStorybookDir = exports.normalizeSchema = exports.updateLintConfig = exports.configureTsSolutionConfig = exports.configureTsProjectConfig = exports.addAngularStorybookTask = exports.addStorybookTask = void 0;
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const path_1 = require("path");
const utilities_1 = require("../../utils/utilities");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const DEFAULT_PORT = 4400;
function addStorybookTask(tree, projectName, uiFramework, configureTestRunner) {
    if (uiFramework === '@storybook/react-native') {
        return;
    }
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    projectConfig.targets['storybook'] = {
        executor: '@nrwl/storybook:storybook',
        options: {
            uiFramework,
            port: DEFAULT_PORT,
            config: {
                configFolder: `${projectConfig.root}/.storybook`,
            },
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@nrwl/storybook:build',
        outputs: ['{options.outputPath}'],
        options: {
            uiFramework,
            outputPath: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            config: {
                configFolder: `${projectConfig.root}/.storybook`,
            },
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (configureTestRunner === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addStorybookTask = addStorybookTask;
function addAngularStorybookTask(tree, projectName, configureTestRunner) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const { ngBuildTarget } = (0, utilities_1.findStorybookAndBuildTargetsAndCompiler)(projectConfig.targets);
    projectConfig.targets['storybook'] = {
        executor: '@storybook/angular:start-storybook',
        options: {
            port: 4400,
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@storybook/angular:build-storybook',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (configureTestRunner === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addAngularStorybookTask = addAngularStorybookTask;
function configureTsProjectConfig(tree, schema) {
    var _a, _b;
    const { name: projectName } = schema;
    let tsConfigPath;
    let tsConfigContent;
    try {
        tsConfigPath = getTsConfigPath(tree, projectName);
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    catch (_c) {
        /**
         * Custom app configurations
         * may contain a tsconfig.json
         * instead of a tsconfig.app.json.
         */
        tsConfigPath = getTsConfigPath(tree, projectName, 'tsconfig.json');
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    if (!((_a = tsConfigContent === null || tsConfigContent === void 0 ? void 0 : tsConfigContent.exclude) === null || _a === void 0 ? void 0 : _a.includes('**/*.stories.ts')) &&
        !((_b = tsConfigContent === null || tsConfigContent === void 0 ? void 0 : tsConfigContent.exclude) === null || _b === void 0 ? void 0 : _b.includes('**/*.stories.js'))) {
        tsConfigContent.exclude = [
            ...(tsConfigContent.exclude || []),
            '**/*.stories.ts',
            '**/*.stories.js',
            ...((0, utilities_1.isFramework)('react', schema) || (0, utilities_1.isFramework)('react-native', schema)
                ? ['**/*.stories.jsx', '**/*.stories.tsx']
                : []),
        ];
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsProjectConfig = configureTsProjectConfig;
function configureTsSolutionConfig(tree, schema) {
    var _a, _b;
    const { name: projectName } = schema;
    const { root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tsConfigPath = (0, path_1.join)(root, 'tsconfig.json');
    const tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    if (!((_b = (_a = tsConfigContent.references) === null || _a === void 0 ? void 0 : _a.map((reference) => reference.path)) === null || _b === void 0 ? void 0 : _b.includes('./.storybook/tsconfig.json'))) {
        tsConfigContent.references = [
            ...(tsConfigContent.references || []),
            {
                path: './.storybook/tsconfig.json',
            },
        ];
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsSolutionConfig = configureTsSolutionConfig;
/**
 * When adding storybook we need to inform TSLint or ESLint
 * of the additional tsconfig.json file which will be the only tsconfig
 * which includes *.stories files.
 *
 * For TSLint this is done via the builder config, for ESLint this is
 * done within the .eslintrc.json file.
 */
function updateLintConfig(tree, schema) {
    const { name: projectName } = schema;
    const { targets, root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tslintTargets = Object.values(targets).filter((target) => target.executor === '@angular-devkit/build-angular:tslint');
    tslintTargets.forEach((target) => {
        target.options.tsConfig = (0, utilities_1.dedupe)([
            ...target.options.tsConfig,
            (0, devkit_1.joinPathFragments)(root, './.storybook/tsconfig.json'),
        ]);
    });
    if (tree.exists((0, path_1.join)(root, '.eslintrc.json'))) {
        (0, devkit_1.updateJson)(tree, (0, path_1.join)(root, '.eslintrc.json'), (json) => {
            var _a, _b, _c, _d;
            if (typeof ((_a = json.parserOptions) === null || _a === void 0 ? void 0 : _a.project) === 'string') {
                json.parserOptions.project = [json.parserOptions.project];
            }
            if (Array.isArray((_b = json.parserOptions) === null || _b === void 0 ? void 0 : _b.project)) {
                json.parserOptions.project = (0, utilities_1.dedupe)([
                    ...json.parserOptions.project,
                    (0, path_1.join)(root, '.storybook/tsconfig.json'),
                ]);
            }
            const overrides = json.overrides || [];
            for (const o of overrides) {
                if (typeof ((_c = o.parserOptions) === null || _c === void 0 ? void 0 : _c.project) === 'string') {
                    o.parserOptions.project = [o.parserOptions.project];
                }
                if (Array.isArray((_d = o.parserOptions) === null || _d === void 0 ? void 0 : _d.project)) {
                    o.parserOptions.project = (0, utilities_1.dedupe)([
                        ...o.parserOptions.project,
                        (0, path_1.join)(root, '.storybook/tsconfig.json'),
                    ]);
                }
            }
            return json;
        });
    }
}
exports.updateLintConfig = updateLintConfig;
function normalizeSchema(schema) {
    const defaults = {
        configureCypress: true,
        linter: linter_1.Linter.TsLint,
        js: false,
    };
    return Object.assign(Object.assign({}, defaults), schema);
}
exports.normalizeSchema = normalizeSchema;
function createRootStorybookDir(tree, js, tsConfiguration) {
    var _a, _b, _c, _d;
    var _e, _f;
    if (tree.exists('.storybook')) {
        devkit_1.logger.warn(`.storybook folder already exists at root! Skipping generating files in it.`);
        return;
    }
    devkit_1.logger.debug(`adding .storybook folder to the root directory`);
    const templatePath = (0, path_1.join)(__dirname, tsConfiguration ? './root-files-ts' : './root-files');
    (0, devkit_1.generateFiles)(tree, templatePath, '', {
        rootTsConfigPath: (0, typescript_1.getRootTsConfigPathInTree)(tree),
    });
    const workspaceConfiguration = (0, devkit_1.readWorkspaceConfiguration)(tree);
    if (workspaceConfiguration.namedInputs) {
        const hasProductionFileset = !!((_a = workspaceConfiguration.namedInputs) === null || _a === void 0 ? void 0 : _a.production);
        if (hasProductionFileset) {
            workspaceConfiguration.namedInputs.production.push('!{projectRoot}/.storybook/**/*');
            workspaceConfiguration.namedInputs.production.push('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)');
        }
        (_b = workspaceConfiguration.targetDefaults) !== null && _b !== void 0 ? _b : (workspaceConfiguration.targetDefaults = {});
        (_c = (_e = workspaceConfiguration.targetDefaults)['build-storybook']) !== null && _c !== void 0 ? _c : (_e['build-storybook'] = {});
        (_d = (_f = workspaceConfiguration.targetDefaults['build-storybook']).inputs) !== null && _d !== void 0 ? _d : (_f.inputs = [
            'default',
            hasProductionFileset ? '^production' : '^default',
        ]);
        workspaceConfiguration.targetDefaults['build-storybook'].inputs.push('{workspaceRoot}/.storybook/**/*');
        (0, devkit_1.updateWorkspaceConfiguration)(tree, workspaceConfiguration);
    }
    if (js) {
        (0, devkit_1.toJS)(tree);
    }
}
exports.createRootStorybookDir = createRootStorybookDir;
function createProjectStorybookDir(tree, projectName, uiFramework, js, tsConfiguration, isNextJs, usesSwc) {
    // Check if root main file is .ts or .js
    if (tree.exists('.storybook/main.ts')) {
        devkit_1.logger.info(`The root Storybook configuration is in TypeScript, 
      so Nx will generate TypeScript Storybook configuration files 
      in this project's .storybook folder as well.`);
        tsConfiguration = true;
    }
    else {
        if (tree.exists('.storybook/main.js')) {
            devkit_1.logger.info(`The root Storybook configuration is in JavaScript, 
        so Nx will generate JavaScript Storybook configuration files 
        in this project's .storybook folder as well.`);
            tsConfiguration = false;
        }
    }
    const { root, projectType } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const projectDirectory = projectType === 'application'
        ? isNextJs
            ? 'components'
            : 'src/app'
        : 'src/lib';
    const storybookRoot = (0, path_1.join)(root, '.storybook');
    if (tree.exists(storybookRoot)) {
        devkit_1.logger.warn(`.storybook folder already exists for ${projectName}! Skipping generating files in it.`);
        return;
    }
    devkit_1.logger.debug(`adding .storybook folder to your ${projectType}`);
    const templatePath = (0, path_1.join)(__dirname, tsConfiguration ? './project-files-ts' : './project-files');
    (0, devkit_1.generateFiles)(tree, templatePath, root, {
        tmpl: '',
        uiFramework,
        offsetFromRoot: (0, devkit_1.offsetFromRoot)(root),
        rootTsConfigPath: (0, typescript_1.getRootTsConfigPathInTree)(tree),
        projectDirectory,
        useWebpack5: uiFramework === '@storybook/angular' ||
            uiFramework === '@storybook/react',
        existsRootWebpackConfig: tree.exists('.storybook/webpack.config.js'),
        projectType,
        mainDir: isNextJs && projectType === 'application' ? 'components' : 'src',
        isNextJs: isNextJs && projectType === 'application',
        usesSwc,
    });
    if (js) {
        (0, devkit_1.toJS)(tree);
    }
}
exports.createProjectStorybookDir = createProjectStorybookDir;
function getTsConfigPath(tree, projectName, path) {
    const { root, projectType } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    return (0, path_1.join)(root, path && path.length > 0
        ? path
        : projectType === 'application'
            ? 'tsconfig.app.json'
            : 'tsconfig.lib.json');
}
exports.getTsConfigPath = getTsConfigPath;
function addBuildStorybookToCacheableOperations(tree) {
    (0, devkit_1.updateJson)(tree, 'nx.json', (json) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        return (Object.assign(Object.assign({}, json), { tasksRunnerOptions: Object.assign(Object.assign({}, ((_a = json.tasksRunnerOptions) !== null && _a !== void 0 ? _a : {})), { default: Object.assign(Object.assign({}, ((_c = (_b = json.tasksRunnerOptions) === null || _b === void 0 ? void 0 : _b.default) !== null && _c !== void 0 ? _c : {})), { options: Object.assign(Object.assign({}, ((_f = (_e = (_d = json.tasksRunnerOptions) === null || _d === void 0 ? void 0 : _d.default) === null || _e === void 0 ? void 0 : _e.options) !== null && _f !== void 0 ? _f : {})), { cacheableOperations: Array.from(new Set([
                            ...((_k = (_j = (_h = (_g = json.tasksRunnerOptions) === null || _g === void 0 ? void 0 : _g.default) === null || _h === void 0 ? void 0 : _h.options) === null || _j === void 0 ? void 0 : _j.cacheableOperations) !== null && _k !== void 0 ? _k : []),
                            'build-storybook',
                        ])) }) }) }) }));
    });
}
exports.addBuildStorybookToCacheableOperations = addBuildStorybookToCacheableOperations;
//# sourceMappingURL=util-functions.js.map