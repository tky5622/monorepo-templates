"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLoaderFromCompiler = exports.createCopyPlugin = exports.getClientEnvironment = exports.getBaseWebpackPartial = void 0;
const path_1 = require("path");
const webpack = require("webpack");
const license_webpack_plugin_1 = require("license-webpack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const hash_format_1 = require("./hash-format");
const tsconfig_paths_webpack_plugin_1 = require("tsconfig-paths-webpack-plugin");
const js_1 = require("@nrwl/js");
const generate_package_json_webpack_plugin_1 = require("./generate-package-json-webpack-plugin");
const nodeExternals = require("webpack-node-externals");
const TerserPlugin = require("terser-webpack-plugin");
const ForkTsCheckerWebpackPlugin = require("fork-ts-checker-webpack-plugin");
const IGNORED_WEBPACK_WARNINGS = [
    /The comment file/i,
    /could not find any license/i,
];
const extensions = ['.ts', '.tsx', '.mjs', '.js', '.jsx'];
function getBaseWebpackPartial(options, internalOptions, context) {
    var _a, _b, _c, _d, _e;
    // If the function is called directly and not through `@nrwl/webpack:webpack` then this target may not be set.
    (_a = options.target) !== null && _a !== void 0 ? _a : (options.target = 'web');
    const mainFields = [
        ...(internalOptions.esm ? ['es2015'] : []),
        'module',
        'main',
    ];
    const hashFormat = (0, hash_format_1.getOutputHashFormat)(options.outputHashing);
    const suffixFormat = internalOptions.esm ? '' : '.es5';
    const filename = internalOptions.isScriptOptimizeOn
        ? `[name]${hashFormat.script}${suffixFormat}.js`
        : '[name].js';
    const chunkFilename = internalOptions.isScriptOptimizeOn
        ? `[name]${hashFormat.chunk}${suffixFormat}.js`
        : '[name].js';
    const mode = internalOptions.isScriptOptimizeOn
        ? 'production'
        : 'development';
    let mainEntry = 'main';
    if (options.outputFileName) {
        mainEntry = (0, path_1.parse)(options.outputFileName).name;
    }
    const additionalEntryPoints = (_c = (_b = options.additionalEntryPoints) === null || _b === void 0 ? void 0 : _b.reduce((obj, current) => (Object.assign(Object.assign({}, obj), { [current.entryName]: current.entryPath })), {})) !== null && _c !== void 0 ? _c : {};
    const webpackConfig = {
        target: options.target,
        entry: Object.assign({ [mainEntry]: [options.main] }, additionalEntryPoints),
        devtool: options.sourceMap === 'hidden'
            ? 'hidden-source-map'
            : options.sourceMap
                ? 'source-map'
                : false,
        mode,
        output: {
            path: options.outputPath,
            filename,
            chunkFilename,
            hashFunction: 'xxhash64',
            // Disabled for performance
            pathinfo: false,
        },
        module: {
            // Enabled for performance
            unsafeCache: true,
            rules: [
                options.target === 'web' && {
                    test: /\.(bmp|png|jpe?g|gif|webp|avif)$/,
                    type: 'asset',
                    parser: {
                        dataUrlCondition: {
                            maxSize: 10000, // 10 kB
                        },
                    },
                },
                {
                    // There's an issue resolving paths without fully specified extensions
                    // See: https://github.com/graphql/graphql-js/issues/2721
                    // TODO(jack): Add a flag to turn this option on like Next.js does via experimental flag.
                    // See: https://github.com/vercel/next.js/pull/29880
                    test: /\.m?jsx?$/,
                    resolve: {
                        fullySpecified: false,
                    },
                },
                createLoaderFromCompiler(options, internalOptions),
            ].filter(Boolean),
        },
        resolve: {
            extensions,
            alias: getAliases(options),
            plugins: [
                new tsconfig_paths_webpack_plugin_1.TsconfigPathsPlugin({
                    configFile: options.tsConfig,
                    extensions,
                    mainFields,
                }),
            ],
            mainFields,
        },
        performance: {
            hints: false,
        },
        plugins: [],
        watch: options.watch,
        watchOptions: {
            poll: options.poll,
        },
        stats: getStatsConfig(options),
        ignoreWarnings: [
            (x) => IGNORED_WEBPACK_WARNINGS.some((r) => typeof x === 'string' ? r.test(x) : r.test(x.message)),
        ],
        experiments: {
            cacheUnaffected: true,
        },
    };
    if (options.target === 'node') {
        webpackConfig.output.libraryTarget = 'commonjs';
        webpackConfig.node = false;
        // could be an object { scripts: boolean; styles: boolean }
        if (options.optimization === true) {
            webpackConfig.optimization = {
                minimize: true,
                minimizer: [
                    new TerserPlugin({
                        terserOptions: {
                            mangle: false,
                            keep_classnames: true,
                        },
                    }),
                ],
                concatenateModules: true,
            };
        }
    }
    else {
        webpackConfig.plugins.push(new webpack.DefinePlugin(getClientEnvironment(mode).stringified));
        if (options.compiler !== 'swc' && internalOptions.isScriptOptimizeOn) {
            webpackConfig.optimization = {
                sideEffects: true,
                minimizer: [
                    new TerserPlugin({
                        parallel: true,
                        terserOptions: {
                            ecma: (internalOptions.esm ? 2016 : 5),
                            safari10: true,
                            output: {
                                ascii_only: true,
                                comments: false,
                                webkit: true,
                            },
                        },
                    }),
                ],
                runtimeChunk: true,
            };
        }
        (_d = webpackConfig.optimization) !== null && _d !== void 0 ? _d : (webpackConfig.optimization = {});
        webpackConfig.optimization.nodeEnv = (_e = process.env.NODE_ENV) !== null && _e !== void 0 ? _e : mode;
    }
    const extraPlugins = [];
    if (!internalOptions.skipTypeCheck && internalOptions.esm) {
        extraPlugins.push(new ForkTsCheckerWebpackPlugin({
            typescript: {
                configFile: options.tsConfig,
                memoryLimit: options.memoryLimit || 2018,
            },
        }));
    }
    if (options.progress) {
        extraPlugins.push(new webpack.ProgressPlugin());
    }
    // TODO  LicenseWebpackPlugin needs a PR for proper typing
    if (options.extractLicenses) {
        extraPlugins.push(new license_webpack_plugin_1.LicenseWebpackPlugin({
            stats: {
                errors: false,
            },
            perChunkOutput: false,
            outputFilename: `3rdpartylicenses.txt`,
        }));
    }
    if (Array.isArray(options.assets) && options.assets.length > 0) {
        extraPlugins.push(createCopyPlugin(options.assets));
    }
    if (options.target === 'node' &&
        options.externalDependencies === 'all' &&
        context) {
        const modulesDir = `${context.root}/node_modules`;
        webpackConfig.externals = [nodeExternals({ modulesDir })];
    }
    else if (Array.isArray(options.externalDependencies)) {
        webpackConfig.externals = [
            function (context, callback) {
                if (options.externalDependencies.includes(context.request)) {
                    // not bundled
                    return callback(null, `commonjs ${context.request}`);
                }
                // bundled
                callback();
            },
        ];
    }
    if (options.generatePackageJson && context) {
        extraPlugins.push(new generate_package_json_webpack_plugin_1.GeneratePackageJsonWebpackPlugin(context, options));
    }
    webpackConfig.plugins = [...webpackConfig.plugins, ...extraPlugins];
    return webpackConfig;
}
exports.getBaseWebpackPartial = getBaseWebpackPartial;
function getAliases(options) {
    return options.fileReplacements.reduce((aliases, replacement) => (Object.assign(Object.assign({}, aliases), { [replacement.replace]: replacement.with })), {});
}
function getStatsConfig(options) {
    return {
        hash: true,
        timings: false,
        cached: false,
        cachedAssets: false,
        modules: false,
        warnings: true,
        errors: true,
        colors: !options.verbose && !options.statsJson,
        chunks: !options.verbose,
        assets: !!options.verbose,
        chunkOrigins: !!options.verbose,
        chunkModules: !!options.verbose,
        children: !!options.verbose,
        reasons: !!options.verbose,
        version: !!options.verbose,
        errorDetails: !!options.verbose,
        moduleTrace: !!options.verbose,
        usedExports: !!options.verbose,
    };
}
function getClientEnvironment(mode) {
    // Grab NODE_ENV and NX_* environment variables and prepare them to be
    // injected into the application via DefinePlugin in webpack configuration.
    const NX_APP = /^NX_/i;
    const raw = Object.keys(process.env)
        .filter((key) => NX_APP.test(key))
        .reduce((env, key) => {
        env[key] = process.env[key];
        return env;
    }, {
        // Useful for determining whether weâ€™re running in production mode.
        NODE_ENV: process.env.NODE_ENV || mode,
    });
    // Stringify all values so we can feed into webpack DefinePlugin
    const stringified = {
        'process.env': Object.keys(raw).reduce((env, key) => {
            env[key] = JSON.stringify(raw[key]);
            return env;
        }, {}),
    };
    return { stringified };
}
exports.getClientEnvironment = getClientEnvironment;
function createCopyPlugin(assets) {
    return new CopyWebpackPlugin({
        patterns: assets.map((asset) => {
            var _a;
            return {
                context: asset.input,
                // Now we remove starting slash to make Webpack place it from the output root.
                to: asset.output,
                from: asset.glob,
                globOptions: {
                    ignore: [
                        '.gitkeep',
                        '**/.DS_Store',
                        '**/Thumbs.db',
                        ...((_a = asset.ignore) !== null && _a !== void 0 ? _a : []),
                    ],
                    dot: true,
                },
            };
        }),
    });
}
exports.createCopyPlugin = createCopyPlugin;
function createLoaderFromCompiler(options, extraOptions) {
    switch (options.compiler) {
        case 'swc':
            return {
                test: /\.([jt])sx?$/,
                loader: require.resolve('swc-loader'),
                exclude: /node_modules/,
                options: {
                    jsc: {
                        parser: {
                            syntax: 'typescript',
                            decorators: true,
                            tsx: true,
                        },
                        transform: {
                            react: {
                                runtime: 'automatic',
                            },
                        },
                        loose: true,
                    },
                },
            };
        case 'tsc':
            const { compilerPluginHooks, hasPlugin } = (0, js_1.loadTsTransformers)(options.transformers);
            return {
                test: /\.([jt])sx?$/,
                loader: require.resolve(`ts-loader`),
                exclude: /node_modules/,
                options: {
                    configFile: options.tsConfig,
                    transpileOnly: !hasPlugin,
                    // https://github.com/TypeStrong/ts-loader/pull/685
                    experimentalWatchApi: true,
                    getCustomTransformers: (program) => ({
                        before: compilerPluginHooks.beforeHooks.map((hook) => hook(program)),
                        after: compilerPluginHooks.afterHooks.map((hook) => hook(program)),
                        afterDeclarations: compilerPluginHooks.afterDeclarationsHooks.map((hook) => hook(program)),
                    }),
                },
            };
        case 'babel':
            return {
                test: /\.([jt])sx?$/,
                loader: (0, path_1.join)(__dirname, 'web-babel-loader'),
                exclude: /node_modules/,
                options: {
                    rootMode: 'upward',
                    cwd: (0, path_1.join)(options.root, options.sourceRoot),
                    emitDecoratorMetadata: extraOptions.emitDecoratorMetadata,
                    isModern: extraOptions.esm,
                    envName: extraOptions.isScriptOptimizeOn
                        ? 'production'
                        : extraOptions.configuration,
                    babelrc: true,
                    cacheDirectory: true,
                    cacheCompression: false,
                },
            };
        default:
            return null;
    }
}
exports.createLoaderFromCompiler = createLoaderFromCompiler;
//# sourceMappingURL=config.js.map