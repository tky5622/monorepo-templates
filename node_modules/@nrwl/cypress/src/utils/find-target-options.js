"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findBuildConfig = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const project_graph_1 = require("nx/src/project-graph/project-graph");
function findBuildConfig(tree, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            // attempt to use the provided target
            const graph = yield (0, devkit_1.createProjectGraphAsync)();
            if (options.buildTarget) {
                return {
                    target: options.buildTarget,
                    config: findInTarget(tree, graph, options),
                };
            }
            // check to see if there is a valid config in the given project
            const selfProject = findTargetOptionsInProject(tree, graph, options.project, options.validExecutorNames);
            if (selfProject) {
                return selfProject;
            }
            // attempt to find any projects with the valid config in the graph that consumes this project
            return yield findInGraph(tree, graph, options);
        }
        catch (e) {
            throw new Error((0, devkit_1.stripIndents) `Error trying to find build configuration. Try manually specifying the build target with the --build-target flag.
    Provided project? ${options.project}
    Provided build target? ${options.buildTarget}
    Provided Executors? ${[...options.validExecutorNames].join(', ')}`);
        }
    });
}
exports.findBuildConfig = findBuildConfig;
function findInTarget(tree, graph, options) {
    var _a, _b;
    const { project, target, configuration } = (0, devkit_1.parseTargetString)(options.buildTarget);
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, project);
    const foundConfig = configuration || ((_b = (_a = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.targets) === null || _a === void 0 ? void 0 : _a[target]) === null || _b === void 0 ? void 0 : _b.defaultConfiguration);
    return (0, devkit_1.readTargetOptions)({ project, target, configuration: foundConfig }, createExecutorContext(graph, projectConfig.targets, project, target, foundConfig));
}
function findInGraph(tree, graph, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const parents = findParentsOfProject(graph, options.project);
        const potentialTargets = [];
        for (const parent of parents) {
            const parentProject = findTargetOptionsInProject(tree, graph, parent.target, options.validExecutorNames);
            if (parentProject) {
                potentialTargets.push(parentProject);
            }
        }
        if (potentialTargets.length > 1) {
            devkit_1.logger.warn((0, devkit_1.stripIndents) `Multiple potential targets found for ${options.project}. Found ${potentialTargets.length}.
    Using ${potentialTargets[0].target}.
    To specify a different target use the --build-target flag.
    `);
        }
        return potentialTargets[0];
    });
}
function findParentsOfProject(graph, projectName) {
    const reversedGraph = (0, devkit_1.reverse)(graph);
    return reversedGraph.dependencies[projectName]
        ? Object.values(reversedGraph.dependencies[projectName])
        : [];
}
function findTargetOptionsInProject(tree, graph, projectName, includes) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    for (const targetName in projectConfig.targets) {
        const targetConfig = projectConfig.targets[targetName];
        if (includes.has(targetConfig.executor)) {
            return {
                target: `${projectName}:${targetName}`,
                config: (0, devkit_1.readTargetOptions)({ project: projectName, target: targetName }, createExecutorContext(graph, projectConfig.targets, projectName, targetName, null)),
            };
        }
    }
}
function createExecutorContext(graph, targets, projectName, targetName, configurationName) {
    const projectConfigs = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(graph);
    return {
        cwd: process.cwd(),
        projectGraph: graph,
        target: targets[targetName],
        targetName,
        configurationName,
        root: devkit_1.workspaceRoot,
        isVerbose: false,
        projectName,
        workspace: Object.assign(Object.assign({}, (0, devkit_1.readNxJson)()), projectConfigs),
    };
}
//# sourceMappingURL=find-target-options.js.map