"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateCypressProject = void 0;
const tslib_1 = require("tslib");
const cypress_version_1 = require("@nrwl/cypress/src/utils/cypress-version");
const devkit_1 = require("@nrwl/devkit");
const executor_options_utils_1 = require("@nrwl/workspace/src/utilities/executor-options-utils");
const versions_1 = require("../../utils/versions");
const conversion_util_1 = require("./conversion.util");
function migrateCypressProject(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        (0, cypress_version_1.assertMinimumCypressVersion)(8);
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/cypress:cypress', (currentValue, projectName, target, configuration) => {
            var _a, _b, _c, _d, _e, _f;
            try {
                const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
                const { cypressConfigPathJson, cypressConfigPathTs } = (0, conversion_util_1.findCypressConfigs)(tree, projectConfig, target, configuration);
                // a matching cypress ts file hasn't been made yet. need to migrate.
                if (tree.exists(cypressConfigPathJson) &&
                    !tree.exists(cypressConfigPathTs)) {
                    let cypressConfigs = (0, conversion_util_1.createNewCypressConfig)(tree, projectConfig, cypressConfigPathJson);
                    (0, conversion_util_1.updateProjectPaths)(tree, projectConfig, cypressConfigs);
                    cypressConfigs = (0, conversion_util_1.updatePluginFile)(tree, projectConfig, cypressConfigs);
                    (0, conversion_util_1.writeNewConfig)(tree, cypressConfigPathTs, cypressConfigs);
                    (0, conversion_util_1.addConfigToTsConfig)(tree, ((_c = (_b = (_a = projectConfig.targets) === null || _a === void 0 ? void 0 : _a[target]) === null || _b === void 0 ? void 0 : _b.configurations) === null || _c === void 0 ? void 0 : _c.tsConfig) ||
                        ((_f = (_e = (_d = projectConfig.targets) === null || _d === void 0 ? void 0 : _d[target]) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.tsConfig) ||
                        (0, devkit_1.joinPathFragments)(projectConfig.root, 'tsconfig.json'), cypressConfigPathTs);
                    tree.delete(cypressConfigPathJson);
                }
                // ts file has been made and matching json file has been removed only need to update the project config
                if (!tree.exists(cypressConfigPathJson) &&
                    tree.exists(cypressConfigPathTs)) {
                    projectConfig.targets[target].options = Object.assign(Object.assign({}, projectConfig.targets[target].options), { cypressConfig: cypressConfigPathTs, testingType: 'e2e' });
                    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
                }
            }
            catch (e) {
                devkit_1.logger.error((0, devkit_1.stripIndents) `
NX There was an error converting ${projectName}:${target}.
You can manually update the project by following the migration guide if need be.
https://nx.dev/cypress/v10-migration-guide
  `);
                throw e;
            }
        });
        (0, devkit_1.updateJson)(tree, 'package.json', (json) => {
            json.devDependencies['cypress'] = versions_1.cypressVersion;
            return json;
        });
        yield (0, devkit_1.formatFiles)(tree);
        return () => {
            (0, devkit_1.installPackagesTask)(tree);
        };
    });
}
exports.migrateCypressProject = migrateCypressProject;
exports.default = migrateCypressProject;
//# sourceMappingURL=migrate-to-cypress-ten.js.map