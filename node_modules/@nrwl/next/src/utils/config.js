"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareConfig = exports.createWebpackConfig = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const tsconfig_paths_webpack_plugin_1 = require("tsconfig-paths-webpack-plugin");
const webpack_1 = require("@nrwl/webpack");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const loadConfig = require('next/dist/server/config').default;
function createWebpackConfig(workspaceRoot, projectRoot, fileReplacements = [], assets = null, dependencies = [], libsDir = '') {
    return function webpackConfig(config, { isServer, defaultLoaders, }) {
        const mainFields = ['es2015', 'module', 'main'];
        const extensions = ['.ts', '.tsx', '.mjs', '.js', '.jsx'];
        let tsConfigPath = (0, path_1.join)(projectRoot, 'tsconfig.json');
        if (dependencies.length > 0) {
            tsConfigPath = (0, buildable_libs_utils_1.createTmpTsConfig)((0, path_1.join)(workspaceRoot, tsConfigPath), workspaceRoot, projectRoot, dependencies);
        }
        config.resolve.plugins = [
            new tsconfig_paths_webpack_plugin_1.TsconfigPathsPlugin({
                configFile: tsConfigPath,
                extensions,
                mainFields,
            }),
        ];
        fileReplacements
            .map((fileReplacement) => ({
            replace: (0, path_1.resolve)(workspaceRoot, fileReplacement.replace),
            with: (0, path_1.resolve)(workspaceRoot, fileReplacement.with),
        }))
            .reduce((alias, replacement) => {
            alias[replacement.replace] = replacement.with;
            return alias;
        }, config.resolve.alias);
        config.module.rules.push({
            test: /\.([jt])sx?$/,
            include: [libsDir],
            exclude: /node_modules/,
            use: [defaultLoaders.babel],
        });
        // Copy (shared) assets to `public` folder during client-side compilation
        if (!isServer && Array.isArray(assets) && assets.length > 0) {
            config.plugins.push((0, webpack_1.createCopyPlugin)((0, webpack_1.normalizeAssets)(assets, workspaceRoot, projectRoot).map((asset) => (Object.assign(Object.assign({}, asset), { output: (0, path_1.join)('../public', asset.output) })))));
        }
        return config;
    };
}
exports.createWebpackConfig = createWebpackConfig;
function prepareConfig(phase, options, context, dependencies, libsDir) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = (yield loadConfig(phase, options.root, null));
        const userWebpack = config.webpack;
        const userNextConfig = getConfigEnhancer(options.nextConfig, context.root);
        // Yes, these do have different capitalisation...
        const outputDir = `${(0, devkit_1.offsetFromRoot)(options.root)}${options.outputPath}`;
        config.distDir =
            config.distDir && config.distDir !== '.next'
                ? (0, devkit_1.joinPathFragments)(outputDir, config.distDir)
                : (0, devkit_1.joinPathFragments)(outputDir, '.next');
        config.webpack = (a, b) => createWebpackConfig(context.root, options.root, options.fileReplacements, options.assets, dependencies, libsDir)(userWebpack ? userWebpack(a, b) : a, b);
        if (typeof userNextConfig !== 'function') {
            throw new Error(`Module specified by 'nextConfig' option does not export a function. It should be of form 'module.exports = (phase, config, options) => config;'`);
        }
        return userNextConfig(phase, config, { options });
    });
}
exports.prepareConfig = prepareConfig;
function getConfigEnhancer(pluginPath, workspaceRoot) {
    if (!pluginPath) {
        return (_, x) => x;
    }
    let fullPath;
    try {
        fullPath = require.resolve(pluginPath);
    }
    catch (_a) {
        fullPath = (0, path_1.join)(workspaceRoot, pluginPath);
    }
    try {
        return require(fullPath);
    }
    catch (_b) {
        throw new Error(`Could not find file specified by 'nextConfig' option: ${fullPath}`);
    }
}
//# sourceMappingURL=config.js.map