"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("dotenv/config");
const devkit_1 = require("@nrwl/devkit");
const chalk = require("chalk");
const fs_1 = require("fs");
const path_1 = require("path");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const config_1 = require("../../utils/config");
const custom_server_1 = require("./lib/custom-server");
const default_server_1 = require("./lib/default-server");
const constants_1 = require("../../utils/constants");
const infoPrefix = `[ ${chalk.dim(chalk.cyan('info'))} ] `;
function serveExecutor(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* serveExecutor_1() {
        // Cast to any to overwrite NODE_ENV
        process.env.NODE_ENV = process.env.NODE_ENV
            ? process.env.NODE_ENV
            : options.dev
                ? 'development'
                : 'production';
        // Setting port that the custom server should use.
        process.env.PORT = options.port;
        const buildOptions = (0, devkit_1.readTargetOptions)((0, devkit_1.parseTargetString)(options.buildTarget), context);
        const root = (0, path_1.resolve)(context.root, buildOptions.root);
        const config = yield tslib_1.__await((0, config_1.prepareConfig)(options.dev ? constants_1.PHASE_DEVELOPMENT_SERVER : constants_1.PHASE_PRODUCTION_SERVER, buildOptions, context, getDependencies(options, context), (0, path_1.join)(context.root, (0, devkit_1.workspaceLayout)().libsDir)));
        if (options.customServerTarget) {
            yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(runCustomServer(root, config, options, buildOptions, context))));
        }
        else {
            yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(runNextDevServer(root, config, options, buildOptions, context))));
        }
    });
}
exports.default = serveExecutor;
function getDependencies(options, context) {
    if (options.buildLibsFromSource) {
        return [];
    }
    else {
        const result = (0, buildable_libs_utils_1.calculateProjectDependencies)(context.projectGraph, context.root, context.projectName, 'build', // should be generalized
        context.configurationName);
        return result.dependencies;
    }
}
function runNextDevServer(root, config, options, buildOptions, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* runNextDevServer_1() {
        const baseUrl = `http://${options.hostname || 'localhost'}:${options.port}`;
        const settings = {
            dev: options.dev,
            dir: root,
            staticMarkup: options.staticMarkup,
            quiet: options.quiet,
            conf: config,
            port: options.port,
            customServer: !!options.customServerTarget,
            hostname: options.hostname || 'localhost',
            // TOOD(jack): Remove in Nx 15
            path: options.customServerPath,
        };
        const server = options.customServerPath
            ? custom_server_1.customServer
            : default_server_1.defaultServer;
        // look for the proxy.conf.json
        let proxyConfig;
        const proxyConfigPath = options.proxyConfig
            ? (0, path_1.join)(context.root, options.proxyConfig)
            : (0, path_1.join)(root, 'proxy.conf.json');
        if ((0, fs_1.existsSync)(proxyConfigPath)) {
            devkit_1.logger.info(`${infoPrefix} found proxy configuration at ${proxyConfigPath}`);
            proxyConfig = require(proxyConfigPath);
        }
        try {
            yield tslib_1.__await(server(settings, proxyConfig));
            devkit_1.logger.info(`[ ${chalk.green('ready')} ] on ${baseUrl}`);
            yield yield tslib_1.__await({
                baseUrl,
                success: true,
            });
            // This Promise intentionally never resolves, leaving the process running
            yield tslib_1.__await(new Promise(() => { }));
        }
        catch (e) {
            if (options.dev) {
                throw e;
            }
            else {
                throw new Error(`Could not start production server. Try building your app with \`nx build ${context.projectName}\`.`);
            }
        }
    });
}
function runCustomServer(root, config, options, buildOptions, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* runCustomServer_1() {
        var e_1, _a;
        process.env.NX_NEXT_DIR = root;
        process.env.NX_NEXT_PUBLIC_DIR = (0, path_1.join)(root, 'public');
        const baseUrl = `http://${options.hostname || 'localhost'}:${options.port}`;
        const customServerBuild = yield tslib_1.__await((0, devkit_1.runExecutor)((0, devkit_1.parseTargetString)(options.customServerTarget), {
            watch: true,
        }, context));
        try {
            for (var customServerBuild_1 = tslib_1.__asyncValues(customServerBuild), customServerBuild_1_1; customServerBuild_1_1 = yield tslib_1.__await(customServerBuild_1.next()), !customServerBuild_1_1.done;) {
                const result = customServerBuild_1_1.value;
                if (!result.success) {
                    return yield tslib_1.__await(result);
                }
                yield yield tslib_1.__await({
                    success: true,
                    baseUrl,
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (customServerBuild_1_1 && !customServerBuild_1_1.done && (_a = customServerBuild_1.return)) yield tslib_1.__await(_a.call(customServerBuild_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        return yield tslib_1.__await({ success: true });
    });
}
//# sourceMappingURL=server.impl.js.map