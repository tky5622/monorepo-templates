"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.librarySchematic = exports.libraryGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const react_1 = require("@nrwl/react");
const run_tasks_in_serial_1 = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const init_1 = require("../init/init");
function libraryGenerator(host, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const name = (0, devkit_1.names)(options.name).fileName;
        const tasks = [];
        const projectDirectory = options.directory
            ? `${(0, devkit_1.names)(options.directory).fileName}/${name}`
            : name;
        const { libsDir } = (0, devkit_1.getWorkspaceLayout)(host);
        const projectRoot = (0, devkit_1.joinPathFragments)(libsDir, projectDirectory);
        const initTask = yield (0, init_1.nextInitGenerator)(host, Object.assign(Object.assign({}, options), { skipFormat: true }));
        tasks.push(initTask);
        const libTask = yield (0, react_1.libraryGenerator)(host, Object.assign(Object.assign({}, options), { compiler: 'swc' }));
        tasks.push(libTask);
        (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, '.babelrc'), (json) => {
            if (options.style === '@emotion/styled') {
                json.presets = [
                    [
                        '@nrwl/next/babel',
                        {
                            'preset-react': {
                                runtime: 'automatic',
                                importSource: '@emotion/react',
                            },
                        },
                    ],
                ];
            }
            else if (options.style === 'styled-jsx') {
                // next.js doesn't require the `styled-jsx/babel' plugin as it is already
                // built-into the `next/babel` preset
                json.presets = ['@nrwl/next/babel'];
                json.plugins = (json.plugins || []).filter((x) => x !== 'styled-jsx/babel');
            }
            else {
                json.presets = ['@nrwl/next/babel'];
            }
            return json;
        });
        (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'tsconfig.json'), (json) => {
            if (options.style === '@emotion/styled') {
                json.compilerOptions.jsxImportSource = '@emotion/react';
            }
            return json;
        });
        (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'tsconfig.lib.json'), (json) => {
            if (!json.files) {
                json.files = [];
            }
            json.files = json.files.map((path) => {
                if (path.endsWith('react/typings/image.d.ts')) {
                    return path.replace('@nrwl/react/typings/image.d.ts', '@nrwl/next/typings/image.d.ts');
                }
                return path;
            });
            return json;
        });
        return (0, run_tasks_in_serial_1.runTasksInSerial)(...tasks);
    });
}
exports.libraryGenerator = libraryGenerator;
exports.default = libraryGenerator;
exports.librarySchematic = (0, devkit_1.convertNxGenerator)(libraryGenerator);
//# sourceMappingURL=library.js.map