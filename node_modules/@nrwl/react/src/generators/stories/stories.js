"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storiesSchematic = exports.storiesGenerator = exports.createAllStories = exports.containsComponentDeclaration = exports.projectRootPath = void 0;
const tslib_1 = require("tslib");
const component_story_1 = require("../component-story/component-story");
const component_cypress_spec_1 = require("../component-cypress-spec/component-cypress-spec");
const ast_utils_1 = require("../../utils/ast-utils");
const ts = require("typescript");
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const utilities_1 = require("@nrwl/storybook/src/utils/utilities");
const minimatch = require("minimatch");
function projectRootPath(config) {
    let projectDir;
    if (config.projectType === 'application') {
        const { nextBuildTarget } = (0, utilities_1.findStorybookAndBuildTargetsAndCompiler)(config.targets);
        if (!!nextBuildTarget) {
            // Next.js apps
            projectDir = 'components';
        }
        else {
            // apps/test-app/src/app
            projectDir = 'app';
        }
    }
    else if (config.projectType == 'library') {
        // libs/test-lib/src/lib
        projectDir = 'lib';
    }
    return (0, devkit_1.joinPathFragments)(config.sourceRoot, projectDir);
}
exports.projectRootPath = projectRootPath;
function containsComponentDeclaration(tree, componentPath) {
    var _a;
    const contents = tree.read(componentPath, 'utf-8');
    if (contents === null) {
        throw new Error(`Failed to read ${componentPath}`);
    }
    const sourceFile = ts.createSourceFile(componentPath, contents, ts.ScriptTarget.Latest, true);
    return !!((0, ast_utils_1.getComponentNode)(sourceFile) ||
        ((_a = (0, ast_utils_1.findExportDeclarationsForJsx)(sourceFile)) === null || _a === void 0 ? void 0 : _a.length));
}
exports.containsComponentDeclaration = containsComponentDeclaration;
function createAllStories(tree, projectName, generateCypressSpecs, js, cypressProject, ignorePaths) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projects = (0, devkit_1.getProjects)(tree);
        const projectConfiguration = projects.get(projectName);
        const { sourceRoot, root } = projectConfiguration;
        let componentPaths = [];
        (0, devkit_1.visitNotIgnoredFiles)(tree, projectRootPath(projectConfiguration), (path) => {
            // Ignore private files starting with "_".
            if ((0, path_1.basename)(path).startsWith('_'))
                return;
            if (ignorePaths === null || ignorePaths === void 0 ? void 0 : ignorePaths.some((pattern) => minimatch(path, pattern)))
                return;
            if ((path.endsWith('.tsx') && !path.endsWith('.spec.tsx')) ||
                (path.endsWith('.js') && !path.endsWith('.spec.js')) ||
                (path.endsWith('.jsx') && !path.endsWith('.spec.jsx'))) {
                // Check if file is NOT a story (either ts/tsx or js/jsx)
                if (!(0, utilities_1.isTheFileAStory)(tree, path)) {
                    // Since the file is not a story
                    // Let's see if the .stories.* file exists
                    const ext = path.slice(path.lastIndexOf('.'));
                    const storyPath = `${path.split(ext)[0]}.stories${ext}`;
                    if (!tree.exists(storyPath)) {
                        componentPaths.push(path);
                    }
                }
            }
        });
        const e2eProjectName = cypressProject || `${projectName}-e2e`;
        const e2eProject = projects.get(e2eProjectName);
        if (generateCypressSpecs && !e2eProject) {
            devkit_1.logger.info(`There was no e2e project "${e2eProjectName}" found, so cypress specs will not be generated. Pass "--cypressProject" to specify a different e2e project name`);
        }
        yield Promise.all(componentPaths.map((componentPath) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const relativeCmpDir = componentPath.replace((0, path_1.join)(sourceRoot, '/'), '');
            if (!containsComponentDeclaration(tree, componentPath)) {
                return;
            }
            yield (0, component_story_1.default)(tree, {
                componentPath: relativeCmpDir,
                project: projectName,
            });
            if (generateCypressSpecs && e2eProject) {
                yield (0, component_cypress_spec_1.default)(tree, {
                    project: projectName,
                    componentPath: relativeCmpDir,
                    js,
                    cypressProject,
                });
            }
        })));
    });
}
exports.createAllStories = createAllStories;
function storiesGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield createAllStories(host, schema.project, schema.generateCypressSpecs, schema.js, schema.cypressProject, schema.ignorePaths);
    });
}
exports.storiesGenerator = storiesGenerator;
exports.default = storiesGenerator;
exports.storiesSchematic = (0, devkit_1.convertNxGenerator)(storiesGenerator);
//# sourceMappingURL=stories.js.map