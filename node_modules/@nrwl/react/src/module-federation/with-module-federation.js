"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withModuleFederation = void 0;
const tslib_1 = require("tslib");
const webpack_utils_1 = require("./webpack-utils");
const devkit_1 = require("@nrwl/devkit");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const package_json_1 = require("./package-json");
const path_1 = require("path");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
function collectDependencies(projectGraph, name, dependencies = {
    workspaceLibraries: new Set(),
    npmPackages: new Set(),
}, seen = new Set()) {
    var _a;
    if (seen.has(name)) {
        return dependencies;
    }
    seen.add(name);
    ((_a = projectGraph.dependencies[name]) !== null && _a !== void 0 ? _a : []).forEach((dependency) => {
        if (dependency.target.startsWith('npm:')) {
            dependencies.npmPackages.add(dependency.target.replace('npm:', ''));
        }
        else {
            dependencies.workspaceLibraries.add(dependency.target);
            collectDependencies(projectGraph, dependency.target, dependencies, seen);
        }
    });
    return dependencies;
}
function mapWorkspaceLibrariesToTsConfigImport(workspaceLibraries, { nodes }) {
    var _a, _b;
    const tsConfigPath = (_a = process.env.NX_TSCONFIG_PATH) !== null && _a !== void 0 ? _a : (0, typescript_1.getRootTsConfigPath)();
    const tsConfig = (0, typescript_1.readTsConfig)(tsConfigPath);
    const tsconfigPathAliases = (_b = tsConfig.options) === null || _b === void 0 ? void 0 : _b.paths;
    if (!tsconfigPathAliases) {
        return workspaceLibraries;
    }
    const mappedLibraries = [];
    for (const lib of workspaceLibraries) {
        const sourceRoot = nodes[lib].data.sourceRoot;
        let found = false;
        for (const [key, value] of Object.entries(tsconfigPathAliases)) {
            if (value.find((p) => p.startsWith(sourceRoot))) {
                mappedLibraries.push(key);
                found = true;
                break;
            }
        }
        if (!found) {
            mappedLibraries.push(lib);
        }
    }
    return mappedLibraries;
}
function getDependentPackagesForProject(projectGraph, name) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { npmPackages, workspaceLibraries } = collectDependencies(projectGraph, name);
        return {
            workspaceLibraries: mapWorkspaceLibrariesToTsConfigImport([...workspaceLibraries], projectGraph),
            npmPackages: [...npmPackages],
        };
    });
}
function determineRemoteUrl(remote, projectGraph) {
    var _a, _b, _c, _d, _e;
    const remoteConfiguration = projectGraph.nodes[remote].data;
    const serveTarget = (_a = remoteConfiguration === null || remoteConfiguration === void 0 ? void 0 : remoteConfiguration.targets) === null || _a === void 0 ? void 0 : _a.serve;
    if (!serveTarget) {
        throw new Error(`Cannot automatically determine URL of remote (${remote}). Looked for property "host" in the project's "serve" target.\n
      You can also use the tuple syntax in your webpack config to configure your remotes. e.g. \`remotes: [['remote1', '//localhost:4201']]\``);
    }
    const host = (_c = (_b = serveTarget.options) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : '//localhost';
    const port = (_e = (_d = serveTarget.options) === null || _d === void 0 ? void 0 : _d.port) !== null && _e !== void 0 ? _e : 4201;
    return `${host.endsWith('/') ? host.slice(0, -1) : host}:${port}/remoteEntry.js`;
}
function mapRemotes(remotes, projectGraph) {
    const mappedRemotes = {};
    for (const remote of remotes) {
        if (Array.isArray(remote)) {
            let [remoteName, remoteLocation] = remote;
            const remoteLocationExt = (0, path_1.extname)(remoteLocation);
            mappedRemotes[remoteName] = ['.js', '.mjs'].includes(remoteLocationExt)
                ? remoteLocation
                : `${remoteLocation.endsWith('/')
                    ? remoteLocation.slice(0, -1)
                    : remoteLocation}/remoteEntry.js`;
        }
        else if (typeof remote === 'string') {
            mappedRemotes[remote] = determineRemoteUrl(remote, projectGraph);
        }
    }
    return mappedRemotes;
}
function applySharedFunction(sharedConfig, sharedFn) {
    if (!sharedFn) {
        return;
    }
    for (const [libraryName, library] of Object.entries(sharedConfig)) {
        const mappedDependency = sharedFn(libraryName, library);
        if (mappedDependency === false) {
            delete sharedConfig[libraryName];
            continue;
        }
        else if (!mappedDependency) {
            continue;
        }
        sharedConfig[libraryName] = mappedDependency;
    }
}
function addStringDependencyToSharedConfig(sharedConfig, dependency, projectGraph) {
    var _a, _b, _c, _d;
    if (projectGraph.nodes[dependency]) {
        sharedConfig[dependency] = { requiredVersion: false };
    }
    else if ((_a = projectGraph.externalNodes) === null || _a === void 0 ? void 0 : _a[`npm:${dependency}`]) {
        const pkgJson = (0, package_json_1.readRootPackageJson)();
        const config = (0, webpack_utils_1.getNpmPackageSharedConfig)(dependency, (_c = (_b = pkgJson.dependencies) === null || _b === void 0 ? void 0 : _b[dependency]) !== null && _c !== void 0 ? _c : (_d = pkgJson.devDependencies) === null || _d === void 0 ? void 0 : _d[dependency]);
        if (!config) {
            return;
        }
        sharedConfig[dependency] = config;
    }
    else {
        throw new Error(`The specified dependency "${dependency}" in the additionalShared configuration does not exist in the project graph. ` +
            `Please check your additionalShared configuration and make sure you are including valid workspace projects or npm packages.`);
    }
}
function applyAdditionalShared(sharedConfig, additionalShared, projectGraph) {
    if (!additionalShared) {
        return;
    }
    for (const shared of additionalShared) {
        if (typeof shared === 'string') {
            addStringDependencyToSharedConfig(sharedConfig, shared, projectGraph);
        }
        else if (Array.isArray(shared)) {
            sharedConfig[shared[0]] = shared[1];
        }
        else if (typeof shared === 'object') {
            sharedConfig[shared.libraryName] = shared.sharedConfig;
        }
    }
}
function withModuleFederation(options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const reactWebpackConfig = require('../../plugins/webpack');
        let projectGraph;
        try {
            projectGraph = (0, devkit_1.readCachedProjectGraph)();
        }
        catch (e) {
            projectGraph = yield (0, devkit_1.createProjectGraphAsync)();
        }
        const project = (_a = projectGraph.nodes[options.name]) === null || _a === void 0 ? void 0 : _a.data;
        if (!project) {
            throw Error(`Cannot find project "${options.name}". Check that the name is correct in module-federation.config.js`);
        }
        const dependencies = yield getDependentPackagesForProject(projectGraph, options.name);
        const sharedLibraries = (0, webpack_utils_1.shareWorkspaceLibraries)(dependencies.workspaceLibraries);
        const npmPackages = (0, webpack_utils_1.sharePackages)(dependencies.npmPackages);
        const sharedDependencies = Object.assign(Object.assign({}, sharedLibraries.getLibraries()), npmPackages);
        applySharedFunction(sharedDependencies, options.shared);
        applyAdditionalShared(sharedDependencies, options.additionalShared, projectGraph);
        return (config) => {
            config = reactWebpackConfig(config);
            config.output.uniqueName = options.name;
            config.output.publicPath = 'auto';
            config.optimization = {
                runtimeChunk: false,
                minimize: false,
            };
            config.experiments = Object.assign(Object.assign({}, config.experiments), { outputModule: true });
            const mappedRemotes = !options.remotes || options.remotes.length === 0
                ? {}
                : mapRemotes(options.remotes, projectGraph);
            config.plugins.push(new ModuleFederationPlugin({
                name: options.name,
                library: {
                    type: 'module',
                },
                filename: 'remoteEntry.js',
                exposes: options.exposes,
                remotes: mappedRemotes,
                shared: Object.assign({}, sharedDependencies),
            }), sharedLibraries.getReplacementPlugin());
            return config;
        };
    });
}
exports.withModuleFederation = withModuleFederation;
//# sourceMappingURL=with-module-federation.js.map