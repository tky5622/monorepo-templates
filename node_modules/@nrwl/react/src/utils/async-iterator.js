"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tapAsyncIterator = exports.mapAsyncIterator = exports.combineAsyncIterators = void 0;
const tslib_1 = require("tslib");
function combineAsyncIterators(...iterators) {
    return tslib_1.__asyncGenerator(this, arguments, function* combineAsyncIterators_1() {
        let [options] = iterators;
        if (typeof options.next === 'function') {
            options = Object.create(null);
        }
        else {
            iterators.shift();
        }
        const getNextAsyncIteratorValue = getNextAsyncIteratorFactory(options);
        try {
            const asyncIteratorsValues = new Map(iterators.map((it, idx) => [idx, getNextAsyncIteratorValue(it, idx)]));
            do {
                const { iterator, index } = yield tslib_1.__await(Promise.race(asyncIteratorsValues.values()));
                if (iterator.done) {
                    asyncIteratorsValues.delete(index);
                }
                else {
                    yield yield tslib_1.__await(iterator.value);
                    asyncIteratorsValues.set(index, getNextAsyncIteratorValue(iterators[index], index));
                }
            } while (asyncIteratorsValues.size > 0);
        }
        finally {
            yield tslib_1.__await(Promise.allSettled(iterators.map((it) => it.return())));
        }
    });
}
exports.combineAsyncIterators = combineAsyncIterators;
function getNextAsyncIteratorFactory(options) {
    return (asyncIterator, index) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const iterator = yield asyncIterator.next();
            return { index, iterator };
        }
        catch (err) {
            if (options.errorCallback) {
                options.errorCallback(err, index);
            }
            return Promise.reject(err);
        }
    });
}
function mapAsyncIterator(data, transform) {
    return tslib_1.__asyncGenerator(this, arguments, function* mapAsyncIterator_1() {
        function f() {
            return tslib_1.__asyncGenerator(this, arguments, function* f_1() {
                const generator = data[Symbol.asyncIterator] || data[Symbol.iterator];
                const iterator = generator.call(data);
                let index = 0;
                let item = yield tslib_1.__await(iterator.next());
                while (!item.done) {
                    yield yield tslib_1.__await(yield tslib_1.__await(transform(yield tslib_1.__await(item.value), index, data)));
                    index++;
                    item = yield tslib_1.__await(iterator.next());
                }
            });
        }
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(f()))));
    });
}
exports.mapAsyncIterator = mapAsyncIterator;
function tapAsyncIterator(data, fn) {
    return tslib_1.__asyncGenerator(this, arguments, function* tapAsyncIterator_1() {
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(mapAsyncIterator(data, (x) => {
            fn(x);
            return x;
        })))));
    });
}
exports.tapAsyncIterator = tapAsyncIterator;
//# sourceMappingURL=async-iterator.js.map