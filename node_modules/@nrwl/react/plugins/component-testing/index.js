"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nxComponentTestingPreset = void 0;
const cypress_preset_1 = require("@nrwl/cypress/plugins/cypress-preset");
const devkit_1 = require("@nrwl/devkit");
const normalize_options_1 = require("@nrwl/webpack/src/executors/webpack/lib/normalize-options");
const get_webpack_config_1 = require("@nrwl/webpack/src/executors/webpack/lib/get-webpack-config");
const custom_webpack_1 = require("@nrwl/webpack/src/utils/webpack/custom-webpack");
const webpack_fallback_1 = require("./webpack-fallback");
/**
 * React nx preset for Cypress Component Testing
 *
 * This preset contains the base configuration
 * for your component tests that nx recommends.
 * including a devServer that supports nx workspaces.
 * you can easily extend this within your cypress config via spreading the preset
 * @example
 * export default defineConfig({
 *   component: {
 *     ...nxComponentTestingPreset(__dirname)
 *     // add your own config here
 *   }
 * })
 *
 * @param pathToConfig will be used for loading project options and to construct the output paths for videos and screenshots
 * @param options override options
 */
function nxComponentTestingPreset(pathToConfig, options) {
    let webpackConfig;
    try {
        const graph = (0, devkit_1.readCachedProjectGraph)();
        const { targets: ctTargets, name: ctProjectName } = (0, cypress_preset_1.getProjectConfigByPath)(graph, pathToConfig);
        const ctTargetName = (options === null || options === void 0 ? void 0 : options.ctTargetName) || 'component-test';
        const ctConfigurationName = process.env.NX_CYPRESS_TARGET_CONFIGURATION;
        const ctExecutorContext = (0, cypress_preset_1.createExecutorContext)(graph, ctTargets, ctProjectName, ctTargetName, ctConfigurationName);
        const ctExecutorOptions = (0, devkit_1.readTargetOptions)({
            project: ctProjectName,
            target: ctTargetName,
            configuration: ctConfigurationName,
        }, ctExecutorContext);
        const buildTarget = ctExecutorOptions.devServerTarget;
        if (!buildTarget) {
            throw new Error(`Unable to find the 'devServerTarget' executor option in the '${ctTargetName}' target of the '${ctProjectName}' project`);
        }
        webpackConfig = buildTargetWebpack(graph, buildTarget, ctProjectName);
    }
    catch (e) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `Unable to build a webpack config with the project graph. 
      Falling back to default webpack config.`);
        devkit_1.logger.warn(e);
        webpackConfig = (0, webpack_fallback_1.buildBaseWebpackConfig)({
            tsConfigPath: 'tsconfig.cy.json',
            compiler: 'babel',
        });
    }
    return Object.assign(Object.assign({}, (0, cypress_preset_1.nxBaseCypressPreset)(pathToConfig)), { devServer: {
            // cypress uses string union type,
            // need to use const to prevent typing to string
            framework: 'react',
            bundler: 'webpack',
            webpackConfig,
        } });
}
exports.nxComponentTestingPreset = nxComponentTestingPreset;
/**
 * apply the schema.json defaults from the @nrwl/web:webpack executor to the target options
 */
function withSchemaDefaults(target, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const options = (0, devkit_1.readTargetOptions)(target, context);
    (_a = options.compiler) !== null && _a !== void 0 ? _a : (options.compiler = 'babel');
    (_b = options.deleteOutputPath) !== null && _b !== void 0 ? _b : (options.deleteOutputPath = true);
    (_c = options.vendorChunk) !== null && _c !== void 0 ? _c : (options.vendorChunk = true);
    (_d = options.commonChunk) !== null && _d !== void 0 ? _d : (options.commonChunk = true);
    (_e = options.runtimeChunk) !== null && _e !== void 0 ? _e : (options.runtimeChunk = true);
    (_f = options.sourceMap) !== null && _f !== void 0 ? _f : (options.sourceMap = true);
    (_g = options.assets) !== null && _g !== void 0 ? _g : (options.assets = []);
    (_h = options.scripts) !== null && _h !== void 0 ? _h : (options.scripts = []);
    (_j = options.styles) !== null && _j !== void 0 ? _j : (options.styles = []);
    (_k = options.budgets) !== null && _k !== void 0 ? _k : (options.budgets = []);
    (_l = options.namedChunks) !== null && _l !== void 0 ? _l : (options.namedChunks = true);
    (_m = options.outputHashing) !== null && _m !== void 0 ? _m : (options.outputHashing = 'none');
    (_o = options.extractCss) !== null && _o !== void 0 ? _o : (options.extractCss = true);
    (_p = options.memoryLimit) !== null && _p !== void 0 ? _p : (options.memoryLimit = 2048);
    (_q = options.maxWorkers) !== null && _q !== void 0 ? _q : (options.maxWorkers = 2);
    (_r = options.fileReplacements) !== null && _r !== void 0 ? _r : (options.fileReplacements = []);
    (_s = options.buildLibsFromSource) !== null && _s !== void 0 ? _s : (options.buildLibsFromSource = true);
    (_t = options.generateIndexHtml) !== null && _t !== void 0 ? _t : (options.generateIndexHtml = true);
    return options;
}
function buildTargetWebpack(graph, buildTarget, componentTestingProjectName) {
    var _a, _b;
    const parsed = (0, devkit_1.parseTargetString)(buildTarget);
    const buildableProjectConfig = (_a = graph.nodes[parsed.project]) === null || _a === void 0 ? void 0 : _a.data;
    const ctProjectConfig = (_b = graph.nodes[componentTestingProjectName]) === null || _b === void 0 ? void 0 : _b.data;
    if (!buildableProjectConfig || !ctProjectConfig) {
        throw new Error((0, devkit_1.stripIndents) `Unable to load project configs from graph. 
    Using build target '${buildTarget}'
    Has build config? ${!!buildableProjectConfig}
    Has component config? ${!!ctProjectConfig}
    `);
    }
    const context = (0, cypress_preset_1.createExecutorContext)(graph, buildableProjectConfig.targets, parsed.project, parsed.target, parsed.target);
    const options = (0, normalize_options_1.normalizeOptions)(withSchemaDefaults(parsed, context), devkit_1.workspaceRoot, buildableProjectConfig.sourceRoot);
    const isScriptOptimizeOn = typeof options.optimization === 'boolean'
        ? options.optimization
        : options.optimization && options.optimization.scripts
            ? options.optimization.scripts
            : false;
    let customWebpack;
    if (options.webpackConfig) {
        customWebpack = (0, custom_webpack_1.resolveCustomWebpackConfig)(options.webpackConfig, options.tsConfig);
        if (typeof customWebpack.then === 'function') {
            // cypress configs have to be sync.
            // TODO(caleb): there might be a workaround with setUpNodeEvents preprocessor?
            devkit_1.logger.warn((0, devkit_1.stripIndents) `Nx React Component Testing Preset currently doesn't support custom async webpack configs. 
      Skipping the custom webpack config option '${options.webpackConfig}'`);
            customWebpack = null;
        }
    }
    const defaultWebpack = (0, get_webpack_config_1.getWebpackConfig)(context, options, true, isScriptOptimizeOn, {
        root: ctProjectConfig.root,
        sourceRoot: ctProjectConfig.sourceRoot,
        configuration: parsed.configuration,
    });
    if (customWebpack) {
        return customWebpack(defaultWebpack, {
            options,
            context,
            configuration: parsed.configuration,
        });
    }
    return defaultWebpack;
}
//# sourceMappingURL=index.js.map