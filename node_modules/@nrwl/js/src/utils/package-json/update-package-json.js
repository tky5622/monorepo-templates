"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpdatedPackageJsonContent = exports.updatePackageJson = void 0;
const devkit_1 = require("@nrwl/devkit");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const path_1 = require("path");
const fileutils_1 = require("nx/src/utils/fileutils");
function getMainFileDirRelativeToProjectRoot(main, projectRoot) {
    const mainFileDir = (0, path_1.dirname)(main);
    const relativeDir = (0, devkit_1.normalizePath)((0, path_1.relative)(projectRoot, mainFileDir));
    return relativeDir === '' ? `./` : `./${relativeDir}/`;
}
function updatePackageJson(options, context, target, dependencies) {
    const pathToPackageJson = (0, path_1.join)(context.root, options.projectRoot, 'package.json');
    const packageJson = (0, fileutils_1.fileExists)(pathToPackageJson)
        ? (0, devkit_1.readJsonFile)(pathToPackageJson)
        : { name: context.projectName };
    (0, devkit_1.writeJsonFile)(`${options.outputPath}/package.json`, getUpdatedPackageJsonContent(packageJson, options));
    if (dependencies.length > 0 &&
        options.updateBuildableProjectDepsInPackageJson) {
        (0, buildable_libs_utils_1.updateBuildableProjectPackageJsonDependencies)(context.root, context.projectName, context.targetName, context.configurationName, target, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
}
exports.updatePackageJson = updatePackageJson;
function getUpdatedPackageJsonContent(packageJson, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    // Default is CJS unless esm is explicitly passed.
    const hasCjsFormat = !options.format || ((_a = options.format) === null || _a === void 0 ? void 0 : _a.includes('cjs'));
    const hasEsmFormat = (_b = options.format) === null || _b === void 0 ? void 0 : _b.includes('esm');
    const mainFile = (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
    const relativeMainFileDir = getMainFileDirRelativeToProjectRoot(options.main, options.projectRoot);
    const typingsFile = `${relativeMainFileDir}${mainFile}.d.ts`;
    const exports = Object.assign({ '.': {} }, packageJson.exports);
    const mainJsFile = (_c = options.outputFileName) !== null && _c !== void 0 ? _c : `${relativeMainFileDir}${mainFile}.js`;
    if (hasEsmFormat) {
        // Unofficial field for backwards compat.
        (_d = packageJson.module) !== null && _d !== void 0 ? _d : (packageJson.module = mainJsFile);
        if (!hasCjsFormat) {
            packageJson.type = 'module';
            (_e = packageJson.main) !== null && _e !== void 0 ? _e : (packageJson.main = mainJsFile);
        }
        exports['.']['import'] = mainJsFile;
    }
    // CJS output may have .cjs or .js file extensions.
    // Bundlers like rollup and esbuild supports .cjs for CJS and .js for ESM.
    // Bundlers/Compilers like webpack, tsc, swc do not have different file extensions.
    if (hasCjsFormat) {
        const { dir, name } = (0, path_1.parse)(mainJsFile);
        const cjsMain = `${dir}/${name}${(_f = options.outputFileExtensionForCjs) !== null && _f !== void 0 ? _f : '.js'}`;
        (_g = packageJson.main) !== null && _g !== void 0 ? _g : (packageJson.main = cjsMain);
        exports['.']['require'] = cjsMain;
    }
    if (options.generateExportsField) {
        packageJson.exports = exports;
    }
    if (!options.skipTypings) {
        packageJson.types = (_h = packageJson.types) !== null && _h !== void 0 ? _h : typingsFile;
    }
    return packageJson;
}
exports.getUpdatedPackageJsonContent = getUpdatedPackageJsonContent;
//# sourceMappingURL=update-package-json.js.map